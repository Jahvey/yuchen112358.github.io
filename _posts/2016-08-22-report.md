---
layout:     post
title:      "Android CPU动态调频"
subtitle:   "interactive governor源码分析"
date:       2016-08-22
author:     "yuchen"
header-img: "img/post-bg-java.jpg"
tags:
    - DVFS
    - Governor
    - Android
---

**文章声明**：本文内容主要源自[CPU动态调频：interactive governor](http://m.blog.csdn.net/article/details?id=45697221)一文,并在其中加入了自己的理解。其中选频函数介绍引自[CPU动态调频：interactive governor如何选频](http://m.blog.csdn.net/article/details?id=45742053)。

本文以Android平台通常采用的interactive governor为例，详细分析了Linux/arm 3.10.9 Kernel中提供的DVFS governor。

**注意：**代码若未指明位置则默认在drivers/cpufreq/cpufreq_interactive.c中。


## interactive governor结构体的定义

```c
struct cpufreq_governor cpufreq_gov_interactive = {
	.name = "interactive",
	.governor = cpufreq_governor_interactive,
	.max_transition_latency = 10000000,//10000000 nano secs = 10 ms
	.owner = THIS_MODULE,
};

```

## cpufreq_governor的定义

```c
//cpufreq.h
struct cpufreq_governor {
	char	name[CPUFREQ_NAME_LEN];
	int	initialized;
	int	(*governor)	(struct cpufreq_policy *policy,
				 unsigned int event);
	ssize_t	(*show_setspeed)	(struct cpufreq_policy *policy,
					 char *buf);
	int	(*store_setspeed)	(struct cpufreq_policy *policy,
					 unsigned int freq);
	unsigned int max_transition_latency; /* HW must be able to switch to
			next freq faster than this value in nano secs or we
			will fallback to performance governor */
	struct list_head	governor_list;
	struct module		*owner;
};

```

* name：governor的名字，此处被赋值为interactive 
* initialized：初始化标志位 
* governor：这个calback用于控制governor的行为，比较重要
* max_transition_latency：硬件从当前频率切换到下一个频率时所用的时间必须比max_transition_latency规定的时间小，否则governor将切换到performance.该数值以纳秒为单位 
* governor_list：所有注册的governor都会被add到这个链表里面 

## 在governor正常工作之前所需做的初始化工作

```c
static int __init cpufreq_interactive_init(void)
{
	unsigned int i;
	struct cpufreq_interactive_cpuinfo *pcpu;

	/* Initalize per-cpu timers */
	for_each_possible_cpu(i) {
		pcpu = &per_cpu(cpuinfo, i);
		init_timer_deferrable(&pcpu->cpu_timer);
		pcpu->cpu_timer.function = cpufreq_interactive_timer;
		pcpu->cpu_timer.data = i;
		init_timer(&pcpu->cpu_slack_timer);
		pcpu->cpu_slack_timer.function = cpufreq_interactive_nop_timer;
		spin_lock_init(&pcpu->load_lock);
		init_rwsem(&pcpu->enable_sem);
	}

	spin_lock_init(&speedchange_cpumask_lock);
	mutex_init(&gov_lock);

	return cpufreq_register_governor(&cpufreq_gov_interactive);
}
```
1. 遍历可能的CPU 
2. get到每个CPU的cpuinfo成员 
3. 初始化可延时定时器 
4. 设置定时器的function，定时器超时时会调用该函数 
5. 设置定时器的data，这里表示CPU ID 
6. 初始化slack定时器 
7. 设置该定时器的function，定时器超时时会调用该函数 
8. 初始化spin_lock 类型的load_lock
9. 初始化可读信号量 
10. 调用cpufreq_register_governor注册interactive governor

## 注册interactive governor的函数cpufreq_register_governor

```c
//cpufreq.c
int cpufreq_register_governor(struct cpufreq_governor *governor)
{
	int err;

	if (!governor)
		return -EINVAL;

	if (cpufreq_disabled())
		return -ENODEV;

	mutex_lock(&cpufreq_governor_mutex);

	governor->initialized = 0;
	err = -EBUSY;
	if (__find_governor(governor->name) == NULL) {
		err = 0;
		list_add(&governor->governor_list, &cpufreq_governor_list);
	}

	mutex_unlock(&cpufreq_governor_mutex);
	return err;
}
```

> `cpufreq_governor_list用来保存已注册的governor`;  
> `__find_governor会在cpufreq_governor_list中遍历寻找是否有与需要register的governor重名的governor，如果没有则将该governor添加到cpufreq_governor_list中。`

以上便是interactive governor的定义，初始化和注册步骤。  

**********

现在我们已经拥有了一个interactive governor，cpufreq core如果想操作governor进行选频，那么interactive governor必须对外提供一个interface以供调用，这就是cpufreq_governor结构体中的governor callback，下面来以这个interface为切入点分析governor是如何工作的。   

```Markdown
The governor->governor callback is called with the current (or to-be-set)
cpufreq_policy struct for that CPU, and an unsigned int event. The
following events are currently defined:
CPUFREQ_GOV_POLICY_INIT:POLICY初始化
CPUFREQ_GOV_POLICY_EXIT：POLICY卸载
CPUFREQ_GOV_START:   This governor shall start its duty for the CPU
             policy->cpu
CPUFREQ_GOV_STOP:    This governor shall end its duty for the CPU
             policy->cpu
CPUFREQ_GOV_LIMITS:  The limits for CPU policy->cpu have changed to
             policy->min and policy->max.
```			 

## 详细分析cpufreq_governor_interactive函数

由cpufreq_gov_interactive定义`.governor = cpufreq_governor_interactive,`可知，governor callback被定义为cpufreq_governor_interactive函数。cpufreq_governor_interactive函数过长，下面进行分段分析：

```c
static int cpufreq_governor_interactive(struct cpufreq_policy *policy,
		unsigned int event)
{
	int rc;
	unsigned int j;
	struct cpufreq_interactive_cpuinfo *pcpu;
	struct cpufreq_frequency_table *freq_table;
	struct cpufreq_interactive_tunables *tunables;
	struct sched_param param = { .sched_priority = MAX_RT_PRIO-1 };
	char speedchange_task_name[TASK_NAME_LEN];
```

pcpu变量描述了cpu相关信息，结构体定义如下：

```c
struct cpufreq_interactive_cpuinfo {
	struct timer_list cpu_timer;
	struct timer_list cpu_slack_timer;
	spinlock_t load_lock; /* protects the next 4 fields */
	u64 time_in_idle;
	u64 time_in_idle_timestamp;
	u64 cputime_speedadj;
	u64 cputime_speedadj_timestamp;
	struct cpufreq_policy *policy;
	struct cpufreq_frequency_table *freq_table;
	unsigned int target_freq;
	unsigned int floor_freq;
	u64 floor_validate_time;
	u64 hispeed_validate_time;
	struct rw_semaphore enable_sem;
	int governor_enabled;
};
```

freq_table表示频率表，结构体定义如下：

```c
//cpufreq.h
struct cpufreq_frequency_table {
	unsigned int	index;     /* any */
	unsigned int	frequency; /* kHz - doesn't need to be in ascending
				    * order */
};
```

可以发现cpufreq_frequency_table是一个node，每个node代表一个频率点，很多node关联在一起就成了一个table。  

让我们继续看cpufreq_governor_interactive函数，struct cpufreq_interactive_tunables *tunables;这个结构体很重要，贯穿了整个governor callback，先给出结构体，接下来在函数中边看边分析。

```c
struct cpufreq_interactive_tunables {
	int usage_count;
	/* Hi speed to bump to from lo speed when load burst (default max) */
	unsigned int hispeed_freq;
	/* Go to hi speed when CPU load at or above this value. */
#define DEFAULT_GO_HISPEED_LOAD 99
	unsigned long go_hispeed_load;
	/* Target load. Lower values result in higher CPU speeds. */
	spinlock_t target_loads_lock;
	unsigned int *target_loads;
	int ntarget_loads;
	/*
	 * The minimum amount of time to spend at a frequency before we can ramp
	 * down.
	 */
#define DEFAULT_MIN_SAMPLE_TIME (80 * USEC_PER_MSEC)
	unsigned long min_sample_time;
	/*
	 * The sample rate of the timer used to increase frequency
	 */
	unsigned long timer_rate;
	/*
	 * Wait this long before raising speed above hispeed, by default a
	 * single timer interval.
	 */
	spinlock_t above_hispeed_delay_lock;
	unsigned int *above_hispeed_delay;
	int nabove_hispeed_delay;
	/* Non-zero means indefinite speed boost active */
	int boost_val;
	/* Duration of a boot pulse in usecs */
	int boostpulse_duration_val;
	/* End time of boost pulse in ktime converted to usecs */
	u64 boostpulse_endtime;
	/*
	 * Max additional time to wait in idle, beyond timer_rate, at speeds
	 * above minimum before wakeup to reduce speed, or -1 if unnecessary.
	 */
#define DEFAULT_TIMER_SLACK (4 * DEFAULT_TIMER_RATE)
	int timer_slack_val;
	bool io_is_busy;

#define TASK_NAME_LEN 15
	/* realtime thread handles frequency scaling */
	struct task_struct *speedchange_task;

	/* handle for get cpufreq_policy */
	unsigned int *policy;
};

```

继续看cpufreq_governor_interactive函数:

```c
if (have_governor_per_policy())
		tunables = policy->governor_data;
	else
		tunables = common_tunables;
```		

have_governor_per_policy判断是否每个policy都有自己的governor，ODROID-XU3中policy都采用interactive，所以这里tuables被赋值为common_tunables。  
common_tunables的定义如下：

```c
/* For cases where we have single governor instance for system */
struct cpufreq_interactive_tunables *common_tunables;
```
在此，只是定义，并没有分配内存和初始化。

继续看cpufreq_governor_interactive函数:

```c
switch (event) {
	case CPUFREQ_GOV_POLICY_INIT:
		if (have_governor_per_policy()) {
			WARN_ON(tunables);
		} else if (tunables) {
			tunables->usage_count++;
			policy->governor_data = tunables;
			return 0;
		}

		tunables = kzalloc(sizeof(*tunables), GFP_KERNEL);
		if (!tunables) {
			pr_err("%s: POLICY_INIT: kzalloc failed\n", __func__);
			return -ENOMEM;
		}

		if (!tuned_parameters[policy->cpu]) {
			tunables->above_hispeed_delay = default_above_hispeed_delay;
			tunables->nabove_hispeed_delay =
				ARRAY_SIZE(default_above_hispeed_delay);
			tunables->go_hispeed_load = DEFAULT_GO_HISPEED_LOAD;
			tunables->target_loads = default_target_loads;
			tunables->ntarget_loads = ARRAY_SIZE(default_target_loads);
			tunables->min_sample_time = DEFAULT_MIN_SAMPLE_TIME;
			tunables->timer_rate = DEFAULT_TIMER_RATE;
			tunables->boostpulse_duration_val = DEFAULT_MIN_SAMPLE_TIME;
			tunables->timer_slack_val = DEFAULT_TIMER_SLACK;
		} else {
			memcpy(tunables, tuned_parameters[policy->cpu], sizeof(*tunables));
			kfree(tuned_parameters[policy->cpu]);
		}
		tunables->usage_count = 1;

		/* update handle for get cpufreq_policy */
		tunables->policy = &policy->policy;

		spin_lock_init(&tunables->target_loads_lock);
		spin_lock_init(&tunables->above_hispeed_delay_lock);

		rc = sysfs_create_group(get_governor_parent_kobj(policy),
				get_sysfs_attr());
		if (rc) {
			kfree(tunables);
			return rc;
		}

		change_sysfs_owner(policy);

		if (!policy->governor->initialized) {
			idle_notifier_register(&cpufreq_interactive_idle_nb);
			cpufreq_register_notifier(&cpufreq_notifier_block,
					CPUFREQ_TRANSITION_NOTIFIER);
		}

		policy->governor_data = tunables;
		if (!have_governor_per_policy())
			common_tunables = tunables;

		break;
```
判断event的类型，并根据event进行不同的操作。  
在include/linux/cpufreq.h中定义了几种Governor Events：

```c
#define CPUFREQ_GOV_START	1
#define CPUFREQ_GOV_STOP	2
#define CPUFREQ_GOV_LIMITS	3
#define CPUFREQ_GOV_POLICY_INIT	4
#define CPUFREQ_GOV_POLICY_EXIT	5
```

---

#### 初始化GOV_POLICY

`CPUFREQ_GOV_POLICY_INIT`  

CPUFREQ_GOV_POLICY_INIT表示要init governor policy. 
首先判断have_governor_per_policy()，前面分析过了，返回false，并且tunables并没有被分配内存，所以执行下一条语句为tunables分配内存：

```c
tunables = kzalloc(sizeof(*tunables), GFP_KERNEL);
```

接下来就是对tunables的初始化：

```c		
if (!tuned_parameters[policy->cpu]) {
	tunables->above_hispeed_delay = default_above_hispeed_delay;
	tunables->nabove_hispeed_delay =
		ARRAY_SIZE(default_above_hispeed_delay);
	tunables->go_hispeed_load = DEFAULT_GO_HISPEED_LOAD;
	tunables->target_loads = default_target_loads;
	tunables->ntarget_loads = ARRAY_SIZE(default_target_loads);
	tunables->min_sample_time = DEFAULT_MIN_SAMPLE_TIME;
	tunables->timer_rate = DEFAULT_TIMER_RATE;
	tunables->boostpulse_duration_val = DEFAULT_MIN_SAMPLE_TIME;
	tunables->timer_slack_val = DEFAULT_TIMER_SLACK;
} else {
	memcpy(tunables, tuned_parameters[policy->cpu], sizeof(*tunables));
	kfree(tuned_parameters[policy->cpu]);
}
tunables->usage_count = 1;

/* update handle for get cpufreq_policy */
tunables->policy = &policy->policy;

spin_lock_init(&tunables->target_loads_lock);
spin_lock_init(&tunables->above_hispeed_delay_lock);
```		

* usage_count表示引用计数，初始化的时候设置为1
* above_hispeed_delay，内核文档： /Documention/cpu-freq/governors.txt

> above_hispeed_delay: When speed is at or above hispeed_freq, wait for
this long before raising speed in response to continued high load.
The format is a single delay value, optionally followed by pairs of
CPU speeds and the delay to use at or above those speeds.  Colons can
be used between the speeds and associated delays for readability.  For
example:
>
>   80000 1300000:200000 1500000:40000
>
> uses delay 80000 uS until CPU speed 1.3 GHz, at which speed delay
200000 uS is used until speed 1.5 GHz, at which speed (and above)
delay 40000 uS is used.  If speeds are specified these must appear in
ascending order.  Default is 20000 uS.

当CPU频率大于等于hispeed_freq，并且此时workload仍在不停增加（continued high load），系统将等待一个above_hispeed_delay的时间。above_hispeed_delay一般是这样一种格式，一个单个的延时数值，后面跟上一组由CPU speeds 和 delay组成的数组，由冒号隔开。例如：  
80000 1300000:200000 1500000:40000  
当频率低于1.3G时，above_hispeed_delay的值取80000，1.3G到1.5G之间取20000，大于1.5G取40000.默认取20000us.如果频率被指定，那么这些数值必须必须是升序的。  

```c
#define DEFAULT_TIMER_RATE (20 * USEC_PER_MSEC)
#define DEFAULT_ABOVE_HISPEED_DELAY DEFAULT_TIMER_RATE
static unsigned int default_above_hispeed_delay[] = {
	DEFAULT_ABOVE_HISPEED_DELAY };
//include/linux/time.h
#define USEC_PER_MSEC	1000L
```

可以看到default_above_hispeed_delay是一个数组，我的环境下只有一个数值20000，above_hispeed_delay的数值就是20000(20*1000)。

* nabove_hispeed_delay:default_above_hispeed_delays数组中元素的个数。
* go_hispeed_load: The CPU load at which to ramp to hispeed_freq.Default is 99%. 
高频阈值。当系统的负载超过该值，升频，否则降频。

```c
#define DEFAULT_GO_HISPEED_LOAD 99
```

调频的时候会用到这个数值，见后文。

By the way, hispeed_freq: Hi speed to bump to from lo speed when load burst (default max) 
当workload达到 go_hispeed_load时，频率将被拉高到这个值，默认的大小由policy来决定。

> hispeed_freq: An intermediate "hi speed" at which to initially ramp
when CPU load hits the value specified in go_hispeed_load.  If load
stays high for the amount of time specified in above_hispeed_delay,
then speed may be bumped higher.  Default is the maximum speed
allowed by the policy at governor initialization time.

* target_loads:使得CPU调整频率来影响当前的CPU workload，促使当前的CPU workload向target_loads靠近.通常，target_loads的值越小，CPU就会越频繁地拉高频率使当前workload低于target_loads.  
例如：频率小于1G时，取85%；1G—-1.7G，取90%；大于1.7G，取99%。默认值取90%.

> target_loads: CPU load values used to adjust speed to influence the
current CPU load toward that value.  In general, the lower the target
load, the more often the governor will raise CPU speeds to bring load
below the target.  The format is a single target load, optionally
followed by pairs of CPU speeds and CPU loads to target at or above
those speeds.  Colons can be used between the speeds and associated
target loads for readability.  For example:
>
>   85 1000000:90 1700000:99
>
>targets CPU load 85% below speed 1GHz, 90% at or above 1GHz, until
1.7GHz and above, at which load 99% is targeted.  If speeds are
specified these must appear in ascending order.  Higher target load
values are typically specified for higher speeds, that is, target load
values also usually appear in an ascending order. The default is
target load 90% for all speeds.

```c
/* Target load.  Lower values result in higher CPU speeds. */
#define DEFAULT_TARGET_LOAD 90
static unsigned int default_target_loads[] = {DEFAULT_TARGET_LOAD};
```

* ntarget_loads：target_loads的个数。

* min_sample_time：最小采样时间，默认是80000us。


> The minimum amount of time to spend at the current
frequency before ramping down. Default is 80000 uS.

* boostpulse_duration_val:

> boost: If non-zero, immediately boost speed of all CPUs to at least
hispeed_freq until zero is written to this attribute.  If zero, allow
CPU speeds to drop below hispeed_freq according to load as usual.
Default is zero.
>
> boostpulse: On each write, immediately boost speed of all CPUs to
hispeed_freq for at least the period of time specified by
boostpulse_duration, after which speeds are allowed to drop below
hispeed_freq according to load as usual.
>
> boostpulse_duration: Length of time to hold CPU speed at hispeed_freq
on a write to boostpulse, before allowing speed to drop according to
load as usual.  Default is 80000 uS.

boost即超频，操作方法是：

```bash
echo 1 > /sys/devices/system/cpu/cpufreq/interactive/boost
```

此时会立即将所有CPU的频率提高到至少hispeed_freq.写入0时，根据workload降低频率.默认为0.  
boostpulse，每次触发boost功能时，立即拉高所有CPU的频率到hispeed_freq并保持在该频率至少boostpulse_duration的时间，在这段时间以后，根据当前的workload，频率才允许被降低。  
boostpulse_duration：默认值80000 uS.ODROID-XU3采用的便是默认值，如下所示：

```c
#define DEFAULT_MIN_SAMPLE_TIME (80 * USEC_PER_MSEC)
#define USEC_PER_MSEC	1000L
```

* timer_rate和timer_slack_val:当CPU不处于idel状态时，timer_rate作为采样速率来计算CPU的workload. 当CPU处于idel状态，此时使用一个可延时定时器，会导致CPU不能从idel状态苏醒来响应定时器. 定时器的最大的可延时时间用timer_slack表示，默认值80000 uS.此处采用默认值，如下所示：

```c
#define DEFAULT_TIMER_RATE (20 * USEC_PER_MSEC)
#define USEC_PER_MSEC	1000L
#define DEFAULT_TIMER_SLACK (4 * DEFAULT_TIMER_RATE)
```

> timer_rate: Sample rate for reevaluating CPU load when the CPU is not
idle.  A deferrable timer is used, such that the CPU will not be woken
from idle to service this timer until something else needs to run.
(The maximum time to allow deferring this timer when not running at
minimum speed is configurable via timer_slack.)  Default is 20000 uS.
> 
> timer_slack: Maximum additional time to defer handling the governor
sampling timer beyond timer_rate when running at speeds above the
minimum.  For platforms that consume additional power at idle when
CPUs are running at speeds greater than minimum, this places an upper
bound on how long the timer will be deferred prior to re-evaluating
load and dropping speed.  For example, if timer_rate is 20000uS and
timer_slack is 10000uS then timers will be deferred for up to 30msec
when not at lowest speed.  A value of -1 means defer timers
indefinitely at all speeds.  Default is 80000 uS.

继续向下看继续看cpufreq_governor_interactive函数:

```c

spin_lock_init(&tunables->target_loads_lock);
spin_lock_init(&tunables->above_hispeed_delay_lock);

rc = sysfs_create_group(get_governor_parent_kobj(policy),
		get_sysfs_attr());
if (rc) {
	kfree(tunables);
	return rc;
}

change_sysfs_owner(policy);

if (!policy->governor->initialized) {
	idle_notifier_register(&cpufreq_interactive_idle_nb);
	cpufreq_register_notifier(&cpufreq_notifier_block,
			CPUFREQ_TRANSITION_NOTIFIER);
}

policy->governor_data = tunables;
if (!have_governor_per_policy())
	common_tunables = tunables;

break;
```

* 初始化tunables结构体中的两个自旋锁. 
* 将tunables指针赋值给policy->governor_data 
* 将tunables指针赋值给common_tunables，这个全局变量会在一些文件的show和store函数中被调用。


`rc = sysfs_create_group(get_governor_parent_kobj(policy),get_sysfs_attr());`中的get_governor_parent_kobj和get_sysfs_attr定义如下：

```c
//get_governor_parent_kobj
static struct kobject *get_governor_parent_kobj(struct cpufreq_policy *policy)
{
	if (have_governor_per_policy())
		return &policy->kobj;
	else
		return cpufreq_global_kobject;
}

//get_sysfs_attr
static struct attribute_group *get_sysfs_attr(void)
{
	if (have_governor_per_policy())
		return &interactive_attr_group_gov_pol;
	else
		return &interactive_attr_group_gov_sys;
}

/* One Governor instance for entire system */
static struct attribute *interactive_attributes_gov_sys[] = {
	&target_loads_gov_sys.attr,
	&above_hispeed_delay_gov_sys.attr,
	&hispeed_freq_gov_sys.attr,
	&go_hispeed_load_gov_sys.attr,
	&min_sample_time_gov_sys.attr,
	&timer_rate_gov_sys.attr,
	&timer_slack_gov_sys.attr,
	&boost_gov_sys.attr,
	&boostpulse_gov_sys.attr,
	&boostpulse_duration_gov_sys.attr,
	&io_is_busy_gov_sys.attr,
	NULL,
};

static struct attribute_group interactive_attr_group_gov_sys = {
	.attrs = interactive_attributes_gov_sys,
	.name = "interactive",
};

```

把上述代码简化一下得到:

```c
      rc = sysfs_create_group(cpufreq_global_kobject,
                interactive_attr_group_gov_sys);
```

在cpufreq_global_kobject所对应的目录cpufreq下创建一个名为interactive的目录，并创建与之关联的属性文件。通过以下方式可以看到这些属性文件：

```bash
ls /sys/devices/system/cpu/cpufreq/interactive/
```

最后注册了两个notification，分别是idle相关和频率改变相关。

**回顾一下CPUFREQ_GOV_POLICY_INIT所做的工作：   
1. 定义并初始化了一个cpufreq_interactive_tunables结构体，将该结构体指针赋值给policy->governor_data，在struct cpufreq_policy结构体中，policy->governor_data为void *指针，现在我们知道它的作用是指向tunables，而tunablesa对应的内存中存放了governor调节频率的参数，这就是policy->governor_data的作用。   
2. 创建对应的目录和属性文件。**

---

#### 卸载GOV_POLICY_EXIT

`CPUFREQ_GOV_POLICY_EXIT`    

这个event对应的操作比较简单一些，主要是做一些policy和governor的“善后”工作。

---

#### 启动Governor

`CPUFREQ_GOV_START`  

> CPUFREQ_GOV_START:   This governor shall start its duty for the CPU
>		     policy->cpu

启动一个governor，看代码:

```c
	case CPUFREQ_GOV_START:
		mutex_lock(&gov_lock);

		freq_table = cpufreq_frequency_get_table(policy->cpu);
		if (!tunables->hispeed_freq)
			tunables->hispeed_freq = policy->max;

		for_each_cpu(j, policy->cpus) {
			pcpu = &per_cpu(cpuinfo, j);
			pcpu->policy = policy;
			pcpu->target_freq = policy->cur;
			pcpu->freq_table = freq_table;
			pcpu->floor_freq = pcpu->target_freq;
			pcpu->floor_validate_time =
				ktime_to_us(ktime_get());
			pcpu->hispeed_validate_time =
				pcpu->floor_validate_time;
			down_write(&pcpu->enable_sem);
			del_timer_sync(&pcpu->cpu_timer);
			del_timer_sync(&pcpu->cpu_slack_timer);
			cpufreq_interactive_timer_start(tunables, j);
			pcpu->governor_enabled = 1;
			up_write(&pcpu->enable_sem);
		}

		snprintf(speedchange_task_name, TASK_NAME_LEN, "cfinteractive%d\n",
					policy->cpu);

		tunables->speedchange_task =
			kthread_create(cpufreq_interactive_speedchange_task, NULL,
				       speedchange_task_name);
		if (IS_ERR(tunables->speedchange_task)) {
			mutex_unlock(&gov_lock);
			return PTR_ERR(tunables->speedchange_task);
		}

		sched_setscheduler_nocheck(tunables->speedchange_task, SCHED_FIFO, &param);
		get_task_struct(tunables->speedchange_task);

#ifdef CONFIG_ARM_EXYNOS_MP_CPUFREQ
		kthread_bind(tunables->speedchange_task, policy->cpu);
#endif

		/* NB: wake up so the thread does not look hung to the freezer */
		wake_up_process(tunables->speedchange_task);

		mutex_unlock(&gov_lock);
		break;
```

首先获取freq_table.  
如果没有设置hispeed_freq的值的话，就设置hispeed_freq为policy->max，和之前介绍hispeed_freq时说的一样.  
接下来是一个for循环，policy->cpus表示所有处于online状态的CPU，for循环遍历所有处于online状态的CPU，在这个循环中：  
get到cpu的cpuinfo结构体并把指针赋值给pcpu，一个struct cpufreq_interactive_cpuinfo结构体指针. 
然后对pcpu的一些成员进行初始化，本质上还是设置online cpus的cpuinfo结构体成员. 
然后调用cpufreq_interactive_timer_start启动相关的定时器 .
启动定时器以后governor就可以工作了，所以设置pcpu->governor_enabled为1.

下面是policy的类型定义：

```c
struct cpufreq_policy {
	/* CPUs sharing clock, require sw coordination */
	cpumask_var_t		cpus;	/* Online CPUs only */
	cpumask_var_t		related_cpus; /* Online + Offline CPUs */

	unsigned int		shared_type; /* ACPI: ANY or ALL affected CPUs
						should set cpufreq */
	unsigned int		cpu;    /* cpu变量记录着用于管理该policy的cpu编号 */
	/*last_cpu则是上一次管理该policy的cpu编号（因为管理policy的cpu可能会被plug out，这时候就要把管理工作迁移到另一个cpu上）*/
	unsigned int		last_cpu; /* cpu nr of previous CPU that managed
					   * this policy */
	struct cpufreq_cpuinfo	cpuinfo;/* see above */

	unsigned int		min;    /* in kHz */
	unsigned int		max;    /* in kHz */
	unsigned int		cur;    /* in kHz, only needed if cpufreq
					 * governors are used */
	unsigned int		policy; /* see above */
	struct cpufreq_governor	*governor; /* see below */
	void			*governor_data;

	struct work_struct	update; /* if update_policy() needs to be
					 * called, but you're in IRQ context */

	struct cpufreq_real_policy	user_policy;

	struct kobject		kobj;
	struct completion	kobj_unregister;
};

```

```c
#define for_each_cpu(cpu, mask)			\
	for ((cpu) = 0; (cpu) < 1; (cpu)++, (void)mask)
```

###### 定时器cpufreq_interactive_timer_start函数

```c

/* The caller shall take enable_sem write semaphore to avoid any timer race.
 * The cpu_timer and cpu_slack_timer must be deactivated when calling this
 * function.
 */
static void cpufreq_interactive_timer_start(
	struct cpufreq_interactive_tunables *tunables, int cpu)
{
	struct cpufreq_interactive_cpuinfo *pcpu = &per_cpu(cpuinfo, cpu);
	unsigned long expires = jiffies +
		usecs_to_jiffies(tunables->timer_rate);
	unsigned long flags;

	if (!tunables->speedchange_task)
		return;

	pcpu->cpu_timer.expires = expires;
	add_timer_on(&pcpu->cpu_timer, cpu);
	if (tunables->timer_slack_val >= 0 &&
	    pcpu->target_freq > pcpu->policy->min) {
		expires += usecs_to_jiffies(tunables->timer_slack_val);
		pcpu->cpu_slack_timer.expires = expires;
		add_timer_on(&pcpu->cpu_slack_timer, cpu);
	}

	spin_lock_irqsave(&pcpu->load_lock, flags);
	pcpu->time_in_idle =
		get_cpu_idle_time(cpu, &pcpu->time_in_idle_timestamp,
				  tunables->io_is_busy);
	pcpu->cputime_speedadj = 0;
	pcpu->cputime_speedadj_timestamp = pcpu->time_in_idle_timestamp;
	spin_unlock_irqrestore(&pcpu->load_lock, flags);
}
```

在进入cpufreq_interactive_timer_start之前有一些deactive的操作：

```c
del_timer_sync(&pcpu->cpu_timer);
del_timer_sync(&pcpu->cpu_slack_timer);
```

cpufreq_interactive_timer_start究竟做的工作：

* 设置定时器的到期时间expire 
* 调用add_timer_on添加定时器，”start a timer on a particular CPU” 。即在指定的CPU上start一个定时器，假如我的手机上有4个CPU，那么将有四个定时器被添加到pcpu->cpu_timer链表中
* cpu_slack_timer也是同样的操作 
* 然后获取该CPU的idle时间，这个数值在统计更新时间的时候会被用到。

```c
pcpu->time_in_idle = get_cpu_idle_time(cpu, &pcpu->time_in_idle_timestamp,
                                            tunables->io_is_busy);
```

然后调用：

```c
    pcpu->cputime_speedadj = 0;
    pcpu->cputime_speedadj_timestamp = pcpu->time_in_idle_timestamp;
```

time_in_idle_timestamp的数值在get_cpu_idle_time函数中被更新，在代码中形参的名字为last_update_time，可以理解为更新time_in_idle的时间戳。网上有人解释为计算机启动到现在的时间，是一样的。

到这里start governor的工作就完成了，主要就是启动了两个定时器，定时器到期的话，会执行相关的操作最终选定要set的频率。   
本来到这里我们应该回到cpufreq_governor_interactive中分析event为CPUFREQ_GOV_LIMITS的情况。   
但是为了思路的流畅性，我们顺着定时器继续追代码，看定时器如何实现选频：

---

`__init cpufreq_interactive_init`函数中：

```c
 cpu->cpu_timer.function = cpufreq_interactive_timer;
 pcpu->cpu_timer.data = i;
```

定时器到期时，调用 cpufreq_interactive_timer,这里data是cpu的索引号，在cpufreq_interactive_init中cpu_timer的data成员被赋值成为CPU的索引号，之后调用cpu_timer.function的时候作为实参,分段看cpufreq_interactive_timercpufreq_interactive_timer函数：

```c
static void cpufreq_interactive_timer(unsigned long data)
{
	u64 now;
	unsigned int delta_time;
	u64 cputime_speedadj;
	int cpu_load;
	struct cpufreq_interactive_cpuinfo *pcpu =
		&per_cpu(cpuinfo, data);
	struct cpufreq_interactive_tunables *tunables =
		pcpu->policy->governor_data;
	unsigned int new_freq;
	unsigned int loadadjfreq;
	unsigned int index;
	unsigned long flags;
	bool boosted;

	if (!down_read_trylock(&pcpu->enable_sem))
		return;
	if (!pcpu->governor_enabled)
		goto exit;

	spin_lock_irqsave(&pcpu->load_lock, flags);
	now = update_load(data);
	delta_time = (unsigned int)(now - pcpu->cputime_speedadj_timestamp);
	cputime_speedadj = pcpu->cputime_speedadj;
	spin_unlock_irqrestore(&pcpu->load_lock, flags);

	if (WARN_ON_ONCE(!delta_time))
		goto rearm;

	do_div(cputime_speedadj, delta_time);
	loadadjfreq = (unsigned int)cputime_speedadj * 100;
	cpu_load = loadadjfreq / pcpu->target_freq;
	boosted = tunables->boost_val || now < tunables->boostpulse_endtime;
```

首先调用update_load，更新工作负载：

```c
static u64 update_load(int cpu)
{
	struct cpufreq_interactive_cpuinfo *pcpu = &per_cpu(cpuinfo, cpu);
	struct cpufreq_interactive_tunables *tunables =
		pcpu->policy->governor_data;
	u64 now;
	u64 now_idle;
	unsigned int delta_idle;
	unsigned int delta_time;
	u64 active_time;

	now_idle = get_cpu_idle_time(cpu, &now, tunables->io_is_busy);
	delta_idle = (unsigned int)(now_idle - pcpu->time_in_idle);
	delta_time = (unsigned int)(now - pcpu->time_in_idle_timestamp);

	if (delta_time <= delta_idle)
		active_time = 0;
	else
		active_time = delta_time - delta_idle;

	pcpu->cputime_speedadj += active_time * pcpu->policy->cur;

	update_cpu_metric(cpu, now, delta_idle, delta_time, pcpu->policy);

	pcpu->time_in_idle = now_idle;
	pcpu->time_in_idle_timestamp = now;
	return now;
}
```

* now_idle:系统启动以后运行的idle的总时间

> the cummulative idle time (since boot) for a given CPU, in microseconds.

* pcpu->time_in_idle：上次统计时的idle的总时间 
* delta_idle：两次统计之间的idle总时间

* now：本次的update time，应该是本次统计idle时的时间戳

> variable to store update time in.

* pcpu->time_in_idle_timestamp，上次统计idle时的时间戳 
* delta_time：两次统计之间系统运行的总时间

若delta_time <= delta_idle，说明运行期间CPU一直在idle，active_time赋值为0. 　　
否则，active_time = delta_time - delta_idle;计算出两次统计之间CPU处于active的总时间。　　

然后更新pcpu的一些成员变量的值: 

* pcpu->cputime_speedadj 这个数值的计算方式是本身加上active_time * pcpu->policy->cur，是从cpufreq_interactive_timer_start到现在的激活时间乘以对应频率值之和. 
* pcpu->time_in_idle = now_idle; 更新系统启动后运行的总idle时间. 
* pcpu->time_in_idle_timestamp = now;更新统计时的时间戳. 

上面这两个数值被更新留作下次update_load使用。

###### CPU负载的计算

下面是update_cpu_metric函数：

```c
void update_cpu_metric(int cpu, u64 now, u64 delta_idle, u64 delta_time,
		       struct cpufreq_policy *policy)
{
	struct cpu_load *pcpuload = &per_cpu(cpuload, cpu);
	unsigned int load;

	/*
	 * Calculate the active time in the previous time window
	 *
	 * load = active time / total_time * 100
	 */
	if (delta_time <= delta_idle)
		load = 0;
	else
		load = div64_u64((100 * (delta_time - delta_idle)), delta_time);

	pcpuload->load = load;
	pcpuload->frequency = policy->cur;
	pcpuload->last_update = now;
#ifdef CONFIG_CPU_THERMAL_IPA_DEBUG
	trace_printk("cpu_load: cpu: %d freq: %u load: %u\n", cpu, policy->cur, load);
#endif
}
```

---

回到cpufreq_interactive_timer，update_load返回了最新一次统计idle时的时间戳，赋值给now。　　

```c
delta_time = (unsigned int)(now - pcpu->cputime_speedadj_timestamp);
```
这里用的cputime_speedadj_timestamp，在函数cpufreq_interactive_timer_resched和cpufreq_interactive_timer_start发现cputime_speedadj_timestamp都被赋值为time_in_idle_timestamp，而start函数或reschedule函数都是在定时器刚启动或重新调度时执行的，所以cputime_speedadj_timestamp是定时器函数启动或重新调度时的时间戳。这对应于pcpu->cputime_speedadj 这个数值是从cpufreq_interactive_timer_start到现在的active时间乘以对应频率值之和。　　

计算本次统计到定时器启动的运行时间。　　

然后取pcpu->cputime_speedadj赋值给局部变量cputime_speedadj，cpu->cputime_speedadj在update_load中已被计算并更新过了。  

接下来的几行代码都是用来计算cpu_load，把这些数值展开看就变得很清晰了：

```
	/*pcpu->cputime_speedadj 这个数值在update_load中已被计算并更新过了，
	　* 其计算方式是本身加上active_time * pcpu->policy->cur*/
	cputime_speedadj = pcpu->cputime_speedadj;
	do_div(cputime_speedadj, delta_time);
	loadadjfreq = (unsigned int)cputime_speedadj * 100;
	cpu_load = loadadjfreq / pcpu->target_freq;
```

设从定时器启动到本次统计总运行时间为X，期间整个过程的每次active 时间与对应频率之积的和为Ａ(注意y是active时间与频率的乘积之和)，则

```c
cputime_speedadj = A / X
cpu_load =A / X / pcpu->target_freq * 100

```

设第i段总时间为x_i,idle时间为y_i，则：

```c
cpu_load = [(x_1-y_1) * freq_1  + (x_2-y_2) * freq_2  +...+(x_cur-y_cur) * freq_cur] /
		   (x_1+x_2+...+x_cur)] / x / pcpu->target_freq * 100

x = x_1+x_2+...+x_cur

cpu_load = {[(x_1-y_1) / x] * [freq_1 / pcpu->target_freq]  + [(x_2-y_2) / x] * [freq_2 / pcpu->target_freq] +...+[(x_cur-y_cur) / x] * [freq_cur / pcpu->target_freq] }* 100

```

为什么要乘以100?　这是因为内核不支持浮点运算。

影响cpu_load的两个因素：

1. idle时间 
2. 过去时间的所有频率/目标频率

有一个疑问：   
cpufreq_interactive_timer函数的目的是为了根据当前的workload选频，得到目标频率，然后传给cpufreq driver来设置频率。如果已经有了目标频率，那么直接调driver设置好了，所以这里的pcpu->target_freq不是本次选频得到的target_freq。  

在cpufreq_interactive_timer的后面代码中，我们看到:

```c
pcpu->target_freq = new_freq;

```

new_freq 是本次选频后得到的新频率，最后赋值给pcpu->target_freq，所以在cpufreq_interactive_timer中，该赋值语句之前的所有pcpu->target_freq都表示是上一次选频的target_freq。

所以更正一下，影响cpu_load的两个因素:

1. idle时间 
2. 过去时间的所有频率/上一次选频频率

带着这个思路继续分析：　　

当cpu_load大于tunables->go_hispeed_load或者tunables->boosted的值为非0，此时我们需要拉高频率。如果上一次选频频率比tunables->hispeed_freq小，那么直接设置new_freq为tunables->hispeed_freq;如果上一次选频频率不小于tunables->hispeed_freq，调用choose_freq函数选频，若选频后仍然达不到tunables->hispeed_freq，那么直接设置new_freq为tunables->hispeed_freq。 　　　

可以看到，当cpu_load大于等于tunables->go_hispeed_load时，new_freq的频率要不小于tunables->hispeed_freq。　　

当cpu_load小于tunables->go_hispeed_load并且tunables->boosted的值为0，调用choose_freq选频。 　

```c

	if (cpu_load >= tunables->go_hispeed_load || boosted) {
		if (pcpu->target_freq < tunables->hispeed_freq) {
			new_freq = tunables->hispeed_freq;
		} else {
			new_freq = choose_freq(pcpu, loadadjfreq);

			if (new_freq < tunables->hispeed_freq)
				new_freq = tunables->hispeed_freq;
		}
	} else {
		new_freq = choose_freq(pcpu, loadadjfreq);
	}

```

###### 选频函数choose_freq

让我们看一下choose_freq函数：

```c
/*
 * If increasing frequencies never map to a lower target load then
 * choose_freq() will find the minimum frequency that does not exceed its
 * target load given the current load.
 */
static unsigned int choose_freq(struct cpufreq_interactive_cpuinfo *pcpu,
		unsigned int loadadjfreq)
{
	unsigned int freq = pcpu->policy->cur;
	unsigned int prevfreq, freqmin, freqmax;
	unsigned int tl;
	int index;

	freqmin = 0;
	freqmax = UINT_MAX;

	do {
		prevfreq = freq;
		/**
		target_loads使得CPU调整频率来影响当前的CPU workload，促使当前的CPU workload向target_loads靠近. 
		通常，target_loads的值越小，CPU就会越频繁地拉高频率使当前workload低于target_loads. 
		例如：频率小于1G时，取85%；1G—-1.7G，取90%；大于1.7G，取99%。默认值取90%.
		tl即为返回的目标负载。
		*/
		tl = freq_to_targetload(pcpu->policy->governor_data, freq);

		/*
		 * Find the lowest frequency where the computed load is less
		 * than or equal to the target load.
		 */

		if (cpufreq_frequency_table_target(
			    pcpu->policy, pcpu->freq_table, loadadjfreq / tl,
			    CPUFREQ_RELATION_L, &index))
			break;
		freq = pcpu->freq_table[index].frequency;

		if (freq > prevfreq) {
			/* The previous frequency is too low. */
			freqmin = prevfreq;

			if (freq >= freqmax) {
				/*
				 * Find the highest frequency that is less
				 * than freqmax.
				 */
				 /*
				 找出频率表中小于 freqmax - 1的最大值
				 */
				if (cpufreq_frequency_table_target(
					    pcpu->policy, pcpu->freq_table,
					    freqmax - 1, CPUFREQ_RELATION_H,
					    &index))
					break;
				freq = pcpu->freq_table[index].frequency;

				if (freq == freqmin) {
					/*
					 * The first frequency below freqmax
					 * has already been found to be too
					 * low.  freqmax is the lowest speed
					 * we found that is fast enough.
					 */
					freq = freqmax;
					break;
				}
			}
		} else if (freq < prevfreq) {
			/* The previous frequency is high enough. */
			freqmax = prevfreq;

			if (freq <= freqmin) {
				/*
				 * Find the lowest frequency that is higher
				 * than freqmin.
				 */
				if (cpufreq_frequency_table_target(
					    pcpu->policy, pcpu->freq_table,
					    freqmin + 1, CPUFREQ_RELATION_L,
					    &index))
					break;
				freq = pcpu->freq_table[index].frequency;

				/*
				 * If freqmax is the first frequency above
				 * freqmin then we have already found that
				 * this speed is fast enough.
				 */
				if (freq == freqmax)
					break;
			}
		}

		/* If same frequency chosen as previous then done. */
	} while (freq != prevfreq);

	return freq;
}
```
choose_freq函数用来选频，使选频后的系统workload小于或等于target load.   
核心思想是：选择最小的频率来满足target load.   
影响选频结果的因素有两个：   
1.两次统计时间内系统频率的平均频率loadadjfreq，   
2.系统设定好的target load，在INIT的时候设定，tunables->target_loads = default_target_loads;   

在一个do-while循环中，进行如下操作:  

* 把上次的freq赋值给prevfreq 
* 通过freq_to_targetload得到target load——tl(目标负载)

在前面讲过：target_loads使得CPU调整频率来影响当前的CPU workload，促使当前的CPU workload向target_loads靠近. 通常，target_loads的值越小，CPU就会越频繁地拉高频率使当前workload低于target_loads. 例如：频率小于1G时，取85%；1G—-1.7G，取90%；大于1.7G，取99%。默认值取90%。

* 然后调用cpufreq_frequency_table_target，取大于等于loadadjfreq / tl(target freq)的最小值. 
loadadjfreq是在governor启动以来的平均频率，除以target load就得到target freq.

```c
loadadjfreq = [(x_1-y_1) * freq_1  + (x_2-y_2) * freq_2  +...+(x_cur-y_cur) * freq_cur] /
		   (x_1+x_2+...+x_cur)] / x * 100
```

情景可能是这样的，刚开始freq = pcpu->policy->cur，备份到prevfreq，调用cpufreq_frequency_table_target得到新的freq，然后执行下面的if判断，在这个判断中会调整freq，见下文。 　　

到了下一次循环，上一次的freq又被备份到prevfreq，然后又调用cpufreq_frequency_table_target得到新的freq，如此往复循环，prevfreq和freq的数值会越来越接近，直到相等，就完成了选频. 　　

总体思路是这样，那么来看if判断所做的工作：　

* 拿freq和prevfreq比较：
* 若freq > prevfreq，则 freqmin = prevfreq;否则 freqmax = prevfreq;
* 如果freq > prevfreq，说明比上次大，但是不能比之前的记录最大值大，否则调节就没有意义了，所以如果freq >= freqmax，那么调用cpufreq_frequency_table_target，找小于freqmax的最近一个频点，如果该频点正好是最小频点，说明只有freqmax可以用了，直接break；
* 如果freq < prevfreq，说明比上次小，但是不能比之前记录的最小值小，否则调节就没有意义了，所以如果freq <= freqmax，那么调用cpufreq_frequency_table_target，找大于freqmax的最近一个频点，如果该频点正好是最大频点，直接break；
* 最后返回选好的频点freq。[^ref]

[^ref]:[CPU动态调频：interactive governor如何选频](http://m.blog.csdn.net/article/details?id=45742053)



继续探究cpufreq_interactive_timer:


```c

	if (pcpu->target_freq >= tunables->hispeed_freq &&
	    new_freq > pcpu->target_freq &&
	    now - pcpu->hispeed_validate_time <
	    freq_to_above_hispeed_delay(tunables, pcpu->target_freq)) {
		trace_cpufreq_interactive_notyet(
			data, cpu_load, pcpu->target_freq,
			pcpu->policy->cur, new_freq);
		goto rearm;
	}
```

freq_to_above_hispeed_delay，只是返回了tunables->above_hispeed_delay[i]的数值，我们只设置了一个数值default_above_hispeed_delay.   
重点是这个成员的含义，可以回头看一下INIT阶段的解释.  
如果满足`pcpu->target_freq >= tunables->hispeed_freq && new_freq > pcpu->target_freq &&`，上一次选频频率已经大于tunables->hispeed_freq，本次选频频率比上次更大（系统仍然想增加频率），`now - pcpu->hispeed_validate_time < freq_to_above_hispeed_delay(tunables, pcpu->target_freq))`表示now是本次采样时间戳，pcpu->hispeed_validate_time是上次hispeed生效的时间戳，如果两次时间间隔比above_hispeed_delay小，那么直接goto rearm，不调节频率。　　

```c

	pcpu->hispeed_validate_time = now;
```

更新hispeed_validate_time为now。

```c
	if (cpufreq_frequency_table_target(pcpu->policy, pcpu->freq_table,
					   new_freq, CPUFREQ_RELATION_L,
					   &index))
		goto rearm;

	new_freq = pcpu->freq_table[index].frequency;
```

cpufreq_frequency_table_target函数源码如下：


```c
int cpufreq_frequency_table_target(struct cpufreq_policy *policy,
				   struct cpufreq_frequency_table *table,
				   unsigned int target_freq,
				   unsigned int relation,
				   unsigned int *index)
{
	struct cpufreq_frequency_table optimal = {
		.index = ~0,
		.frequency = 0,
	};
	struct cpufreq_frequency_table suboptimal = {
		.index = ~0,
		.frequency = 0,
	};
	unsigned int i;

	pr_debug("request for target %u kHz (relation: %u) for cpu %u\n",
					target_freq, relation, policy->cpu);

	switch (relation) {
	case CPUFREQ_RELATION_H:
		suboptimal.frequency = ~0;
		break;
	case CPUFREQ_RELATION_L:
		optimal.frequency = ~0;
		break;
	}

	for (i = 0; (table[i].frequency != CPUFREQ_TABLE_END); i++) {
		unsigned int freq = table[i].frequency;
		if (freq == CPUFREQ_ENTRY_INVALID)
			continue;
		if ((freq < policy->min) || (freq > policy->max))
			continue;
		switch (relation) {
		case CPUFREQ_RELATION_H:
			if (freq <= target_freq) {
				if (freq >= optimal.frequency) {
					optimal.frequency = freq;
					optimal.index = i;
				}
			} else {
				if (freq <= suboptimal.frequency) {
					suboptimal.frequency = freq;
					suboptimal.index = i;
				}
			}
			break;
		case CPUFREQ_RELATION_L:
			if (freq >= target_freq) {
				if (freq <= optimal.frequency) {
					optimal.frequency = freq;
					optimal.index = i;
				}
			} else {
				if (freq >= suboptimal.frequency) {
					suboptimal.frequency = freq;
					suboptimal.index = i;
				}
			}
			break;
		}
	}
	if (optimal.index > i) {
		if (suboptimal.index > i)
			return -EINVAL;
		*index = suboptimal.index;
	} else
		*index = optimal.index;

	pr_debug("target is %u (%u kHz, %u)\n", *index, table[*index].frequency,
		table[*index].index);

	return 0;
}
```


`cpufreq_frequency_table_target(pcpu->policy, pcpu->freq_table,new_freq,CPUFREQ_RELATION_L,&index)`即是取freq table中大于或等于new_freq的频率中最小的一个频率，返回index，再由index得到new freq，前面已经得到new freq了，这里为什么要再来一次?因为调频不是连续的，只能取频率表中的若干值。（`CPUFREQ_RELATION_H`表示取即是取freq table中小于或等于new_freq的频率中最大的一个频率）。



```c

	/*
	 * Do not scale below floor_freq unless we have been at or above the
	 * floor frequency for the minimum sample time since last validated.
	 */
	if (new_freq < pcpu->floor_freq) {
		if (now - pcpu->floor_validate_time <
				tunables->min_sample_time) {
			trace_cpufreq_interactive_notyet(
				data, cpu_load, pcpu->target_freq,
				pcpu->policy->cur, new_freq);
			goto rearm;
		}
	}
```

当new_freq < pcpu->floor_freq，并且两次floor_validate_time的间隔小于min_sample_time，此时不需要更新频率.网上有大神说，“在最小抽样周期间隔内，CPU的频率是不会变化的”。

```c
	/*
	 * Update the timestamp for checking whether speed has been held at
	 * or above the selected frequency for a minimum of min_sample_time,
	 * if not boosted to hispeed_freq.  If boosted to hispeed_freq then we
	 * allow the speed to drop as soon as the boostpulse duration expires
	 * (or the indefinite boost is turned off).
	 */

	if (!boosted || new_freq > tunables->hispeed_freq) {
		pcpu->floor_freq = new_freq;
		pcpu->floor_validate_time = now;
	}
```


以上做一些更新数据的工作。

```c

	if (pcpu->policy->cur == new_freq) {
		trace_cpufreq_interactive_already(
			data, cpu_load, pcpu->target_freq,
			pcpu->policy->cur, new_freq);
		goto rearm_if_notmax;
	}
```

```c
rearm_if_notmax:
	/*
	 * Already set max speed and don't see a need to change that,
	 * wait until next idle to re-evaluate, don't need timer.
	 */
	if (pcpu->target_freq == pcpu->policy->max)
		goto exit;
```

如果两次选频频率一样并且上一次选频频率不大于当前频率，那么进入rearm_if_notmax判断是否pcpu->target_freq == pcpu->policy->max，如果相等，那么直接退出，不需要调频，当前频率已经处于max speed。

```c
	trace_cpufreq_interactive_target(data, cpu_load, pcpu->target_freq,
					 pcpu->policy->cur, new_freq);

	pcpu->target_freq = new_freq;
	spin_lock_irqsave(&speedchange_cpumask_lock, flags);
	cpumask_set_cpu(data, &speedchange_cpumask);
	spin_unlock_irqrestore(&speedchange_cpumask_lock, flags);
	wake_up_process(tunables->speedchange_task);
```

###### 调频线程cpufreq_interactive_speedchange_task

将new_freq赋值给target_freq，更新目标频率的数值.   
设置需要调节频率的CPUcore的cpumask,唤醒speedchange_task线程，改变CPU频率。   
speedchange_task的定义如下：

```c
struct cpufreq_interactive_tunables {
......

/* realtime thread handles frequency scaling */
static struct task_struct *speedchange_task;

......
};

```

对应的线程如下：

```c

tunables->speedchange_task =
	kthread_create(cpufreq_interactive_speedchange_task, NULL,
			   speedchange_task_name);

```

cpufreq_interactive_speedchange_task函数定义如下：

```c

static int cpufreq_interactive_speedchange_task(void *data)
{
	unsigned int cpu;
	cpumask_t tmp_mask;
	unsigned long flags;
	struct cpufreq_interactive_cpuinfo *pcpu;

	while (!kthread_should_stop()) {
		set_current_state(TASK_INTERRUPTIBLE);
		spin_lock_irqsave(&speedchange_cpumask_lock, flags);

		if (cpumask_empty(&speedchange_cpumask)) {
			spin_unlock_irqrestore(&speedchange_cpumask_lock,
					       flags);
			schedule();

			if (kthread_should_stop())
				break;

			spin_lock_irqsave(&speedchange_cpumask_lock, flags);
		}

		set_current_state(TASK_RUNNING);
		tmp_mask = speedchange_cpumask;
		cpumask_clear(&speedchange_cpumask);
		spin_unlock_irqrestore(&speedchange_cpumask_lock, flags);

		for_each_cpu(cpu, &tmp_mask) {
			unsigned int j;
			unsigned int max_freq = 0;
#ifdef CONFIG_ARM_EXYNOS_MP_CPUFREQ
			unsigned int smp_id = smp_processor_id();

			if (exynos_boot_cluster == CA7) {
				if ((smp_id == 0 && cpu >= NR_CA7) ||
					(smp_id == NR_CA7 && cpu < NR_CA7))
					continue;
			} else {
				if ((smp_id == 0 && cpu >= NR_CA15) ||
					(smp_id == NR_CA15 && cpu < NR_CA15))
					continue;
			}
#endif

			pcpu = &per_cpu(cpuinfo, cpu);

			if (!down_read_trylock(&pcpu->enable_sem))
				continue;
			if (!pcpu->governor_enabled) {
				up_read(&pcpu->enable_sem);
				continue;
			}

			for_each_cpu(j, pcpu->policy->cpus) {
				struct cpufreq_interactive_cpuinfo *pjcpu =
					&per_cpu(cpuinfo, j);

				if (pjcpu->target_freq > max_freq)
					max_freq = pjcpu->target_freq;
			}

			if (max_freq != pcpu->policy->cur)
				__cpufreq_driver_target(pcpu->policy,
							max_freq,
							CPUFREQ_RELATION_H);
			trace_cpufreq_interactive_setspeed(cpu,
						     pcpu->target_freq,
						     pcpu->policy->cur);

			up_read(&pcpu->enable_sem);
		}
	}

	return 0;
}
```

一个while循环中，遍历speedchange_cpumask相关的CPU，然后再次遍历所有online CPU，得到最大的target_freq，将target_freq赋值给max_freq，即我们需要设置的CPU频率. 
若max_freq != pcpu->policy->cur,说明当前频率不等于我们需要设置的频率，调用`__cpufreq_driver_target`完成频率设置. 
`__cpufreq_driver_target`会调用对应的callback完成频率设置，具体和cpufreq driver相关，需要driver工程师根据自己的平台实现。　　　

**关于`CPUFREQ_RELATION_H／CPUFREQ_RELATION_L`:**　　

`CPUFREQ_RELATION_H`:取小于目标值的最大值；<br>
`CPUFREQ_RELATION_L`取大于目标值的最小值。　　

cpufreq_interactive_timer函数的尾巴：

```c
rearm:
	if (!timer_pending(&pcpu->cpu_timer))
		cpufreq_interactive_timer_resched(pcpu);

exit:
	up_read(&pcpu->enable_sem);
	return;
}
```

**注意：** 定时器在rearm标识处被重新调度：　　

通过调用timer_pending（如果正在等待，将返回 1）来发现计时器是否正在等待（还没有发出），如果不是在等待，则重新调度定时器。在cpufreq_interactive_timer_resched函数中使用了mod_timer_pinned函数来更改已经激活的定时器超时时间并启动定时器。　　

> mod_timer_pinned is a way to update the expire field of an active timer (if the timer is inactive it will be activated) and not allow the timer to be migrated to a different CPU.
>
>mod_timer_pinned(timer, expires) is equivalent to:
>
>del_timer(timer); timer->expires = expires; add_timer(timer);

cpufreq_interactive_timer_resched函数定义如下：

```c

static void cpufreq_interactive_timer_resched(
	struct cpufreq_interactive_cpuinfo *pcpu)
{
	struct cpufreq_interactive_tunables *tunables =
		pcpu->policy->governor_data;
	unsigned long expires;
	unsigned long flags;

	if (!tunables->speedchange_task)
		return;

	spin_lock_irqsave(&pcpu->load_lock, flags);
	pcpu->time_in_idle =
		get_cpu_idle_time(smp_processor_id(),
				  &pcpu->time_in_idle_timestamp,
				  tunables->io_is_busy);
	pcpu->cputime_speedadj = 0;
	pcpu->cputime_speedadj_timestamp = pcpu->time_in_idle_timestamp;
	expires = jiffies + usecs_to_jiffies(tunables->timer_rate);
	mod_timer_pinned(&pcpu->cpu_timer, expires);

	if (tunables->timer_slack_val >= 0 &&
	    pcpu->target_freq > pcpu->policy->min) {
		expires += usecs_to_jiffies(tunables->timer_slack_val);
		mod_timer_pinned(&pcpu->cpu_slack_timer, expires);
	}

	spin_unlock_irqrestore(&pcpu->load_lock, flags);
}
```

------



回顾一下之前的工作，我们分析了interactive governor的创建，初始化。　　<br>
如果CPUFREQ core想要启用interactive governor，就要调用interactive governor提供的interface（cpufreq_governor结构体中定义的函数指针governor，其被初始化为`.governor = cpufreq_governor_interactive,`）。<br>
在这个回调函数governor中，分析了governor在policy方面的初始化，start一个governor，然后调频的工作就交给了定时器（定时器在start governor的时候被启动）。<br>
在定时器中，计算cpu_load，然后根据cpu_load来选频，然后更新pcpu的一些数据，选频得到的频率交由CPUFREQ driver来设置到硬件中去。<br>

顺便说一下：<br>
当一个governor被policy选定后，核心层会通过`__cpufreq_set_policy`函数对该cpu的policy进行设定。如果policy认为这是一个新的governor（和原来使用的旧的governor不相同），policy会通过`__cpufreq_governor`函数，并传递CPUFREQ_GOV_POLICY_INIT参数，而`__cpufreq_governor`函数实际上是调用cpufreq_governor结构中的governor回调函数。　　

核心层会通过`__cpufreq_set_policy`函数，通过CPUFREQ_GOV_POLICY_INIT参数，完成了对governor的初始化工作，紧接着，`__cpufreq_set_policy`会通过CPUFREQ_GOV_START参数，和初始化governor的流程一样启动一个governor。<br>
下面是`__cpufreq_set_policy`函数的定义：

```c

static int __cpufreq_set_policy(struct cpufreq_policy *data,
				struct cpufreq_policy *policy)
{
	int ret = 0, failed = 1;

	pr_debug("setting new policy for CPU %u: %u - %u kHz\n", policy->cpu,
		policy->min, policy->max);

	memcpy(&policy->cpuinfo, &data->cpuinfo,
				sizeof(struct cpufreq_cpuinfo));

	if ((policy->min > data->max || policy->max < data->min) &&
		(policy->max < policy->min)) {
		ret = -EINVAL;
		goto error_out;
	}

	/* verify the cpu speed can be set within this limit */
	ret = cpufreq_driver->verify(policy);
	if (ret)
		goto error_out;

	/* adjust if necessary - all reasons */
	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
			CPUFREQ_ADJUST, policy);

	/* adjust if necessary - hardware incompatibility*/
	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
			CPUFREQ_INCOMPATIBLE, policy);

	/* verify the cpu speed can be set within this limit,
	   which might be different to the first one */
	ret = cpufreq_driver->verify(policy);
	if (ret)
		goto error_out;

	/* notification of the new policy */
	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
			CPUFREQ_NOTIFY, policy);

	data->min = policy->min;
	data->max = policy->max;

	pr_debug("new min and max freqs are %u - %u kHz\n",
					data->min, data->max);

	if (cpufreq_driver->setpolicy) {
		data->policy = policy->policy;
		pr_debug("setting range\n");
		ret = cpufreq_driver->setpolicy(policy);
	} else {
		if (policy->governor != data->governor) {
			/* save old, working values */
			struct cpufreq_governor *old_gov = data->governor;

			pr_debug("governor switch\n");

			/* end old governor */
			if (data->governor) {
				__cpufreq_governor(data, CPUFREQ_GOV_STOP);
				unlock_policy_rwsem_write(policy->cpu);
				__cpufreq_governor(data,
						CPUFREQ_GOV_POLICY_EXIT);
				lock_policy_rwsem_write(policy->cpu);
			}

			/* start new governor */
			data->governor = policy->governor;
			if (!__cpufreq_governor(data, CPUFREQ_GOV_POLICY_INIT)) {
				if (!__cpufreq_governor(data, CPUFREQ_GOV_START)) {
					failed = 0;
				} else {
					unlock_policy_rwsem_write(policy->cpu);
					__cpufreq_governor(data,
							CPUFREQ_GOV_POLICY_EXIT);
					lock_policy_rwsem_write(policy->cpu);
				}
			}

			if (failed) {
				/* new governor failed, so re-start old one */
				pr_debug("starting governor %s failed\n",
							data->governor->name);
				if (old_gov) {
					data->governor = old_gov;
					__cpufreq_governor(data,
							CPUFREQ_GOV_POLICY_INIT);
					__cpufreq_governor(data,
							   CPUFREQ_GOV_START);
				}
				ret = -EINVAL;
				goto error_out;
			}
			/* might be a policy change, too, so fall through */
		}
		pr_debug("governor: change or update limits\n");
		__cpufreq_governor(data, CPUFREQ_GOV_LIMITS);
	}

error_out:
	return ret;
}
```

---

#### 停止Governor

`CPUFREQ_GOV_STOP`　　


现在，回到coufreq_gov_interactive.governor这个callbak，继续向下分析：

```c
	case CPUFREQ_GOV_STOP:
		mutex_lock(&gov_lock);
		//回顾一下：policy->cpus指online的CPU
		for_each_cpu(j, policy->cpus) {
			pcpu = &per_cpu(cpuinfo, j);
			down_write(&pcpu->enable_sem);
			pcpu->governor_enabled = 0;
			del_timer_sync(&pcpu->cpu_timer);
			del_timer_sync(&pcpu->cpu_slack_timer);
			up_write(&pcpu->enable_sem);
		}

		kthread_stop(tunables->speedchange_task);
		put_task_struct(tunables->speedchange_task);
		tunables->speedchange_task = NULL;

		mutex_unlock(&gov_lock);
		break;
```

遍历所有online的cpu： 　　

* 获取cpuinfo 
* 设置pcpu->governor_enabled为0 
* 删除两个定时器

---

#### 更改Governor的上下限值

`CPUFREQ_GOV_LIMITS`  


```c
	case CPUFREQ_GOV_LIMITS:
		if (policy->max < policy->cur)
			__cpufreq_driver_target(policy,
					policy->max, CPUFREQ_RELATION_H);
		else if (policy->min > policy->cur)
			__cpufreq_driver_target(policy,
					policy->min, CPUFREQ_RELATION_L);
		for_each_cpu(j, policy->cpus) {
			pcpu = &per_cpu(cpuinfo, j);

			/* hold write semaphore to avoid race */
			down_write(&pcpu->enable_sem);
			if (pcpu->governor_enabled == 0) {
				up_write(&pcpu->enable_sem);
				continue;
			}

			/* update target_freq firstly */
			if (policy->max < pcpu->target_freq)
				pcpu->target_freq = policy->max;
			else if (policy->min > pcpu->target_freq)
				pcpu->target_freq = policy->min;

			/* Reschedule timer.
			 * Delete the timers, else the timer callback may
			 * return without re-arm the timer when failed
			 * acquire the semaphore. This race may cause timer
			 * stopped unexpectedly.
			 */
			del_timer_sync(&pcpu->cpu_timer);
			del_timer_sync(&pcpu->cpu_slack_timer);
			cpufreq_interactive_timer_start(tunables, j);
			up_write(&pcpu->enable_sem);
		}
		break;
	}
	return 0;
}
```

该event被调用的场景是：change or update limits(即改变频率的最大值/最小值)。 　　

当policy的max或min被改变时，会调用cpufreq_update_policy—>cpufreq_set_policy—>__cpufreq_governor，在__cpufreq_governor中policy->governor->governor调用governor的governor callback。　　

然后执行CPUFREQ_GOV_LIMITS下的代码。此时传入cpufreq_governor_interactive的policy指针已经是min或max被改变后的新policy了 
对于新policy的处理如下：

* 改变当前频率，使其符合新policy的范围 　　
* 遍历所有online CPU： 　　
	+ 判断pcpu->target_freq的值，确保其在新policy的范围内 　　
	+ 删除两个定时器链表
	+ 调用cpufreq_interactive_timer_start,重新add定时器 　　


## 附录

#### cpufreq driver

通过clock framework提供的API，将CPU的频率设置为对应的值。  
通过regulator framework提供的API，将CPU的电压设置为对应的值。

#### cpufreq governor
gov_check_cpu  计算cpu负载的回调函数，通常会直接调用公共层提供的dbs_check_cpu函数完成实际的计算工作。