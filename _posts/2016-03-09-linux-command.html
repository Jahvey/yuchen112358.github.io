---
layout: post
title: "Linux命令学习笔记（1）"
---
<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>linux命令学习.html</title>
  <meta name="generator" content="Haroopad 0.12.2" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF) repeat scroll 0 0 transparent;background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:medium none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:medium none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:medium none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:none no-repeat scroll 5px -27px #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:none repeat scroll 0 0 #FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:none repeat scroll 0 0 #EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:none repeat scroll 0 0 #75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:#1A3C6C solid 1px;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-bottom-width:0;border-left-width:0;border-right-width:0;border-top-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin-bottom:0;margin-left:0;margin-right:0;margin-top:0;max-width:none;min-height:0;outline-color:#112644;outline-style:none;outline-width:0;overflow-x:visible;overflow-y:visible;padding-bottom:0;padding-left:0;padding-right:0;padding-top:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;border:0 none;color:#ccc;height:3px;padding:0}hr.underscore{border:0 none!important;height:30px;padding:0;-webkit-margin-before:0;-webkit-margin-after:0}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:#fff url(../img/ajax.gif) no-repeat center center}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}.markdown{padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-break:break-all;word-wrap:break-word}.markdown pre{border-radius:3px;word-break:break-all;word-wrap:break-word;overflow:auto}.markdown pre code{display:block}.markdown pre>code{border:1px solid #ccc;white-space:pre;padding:.5em;margin:0}.markdown code{border-radius:3px;word-break:break-all;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown table{padding:0;border-collapse:collapse;border-spacing:0}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}.markdown em.underline{font-style:normal;text-decoration:underline}.markdown strong.highlight{color:#000;padding:0 5px;background-color:#fdffb6;-webkit-box-shadow:#fdffb6 0 0 5px;-moz-box-shadow:#fdffb6 0 0 5px;box-shadow:#fdffb6 0 0 5px}.solarized-light{padding:20px;color:#737373;font-size:15px;font-family:"Lucida Grande","Lucida Sans Unicode","Lucida Sans",AppleSDGothicNeo-Medium,'Segoe UI','Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fdf6e3;-webkit-font-smoothing:antialiased}.solarized-light a{color:#1e6ea7}.solarized-light a:hover{color:#268bd2}.solarized-light h1,.solarized-light h2,.solarized-light h3,.solarized-light h4,.solarized-light h5{color:#b58900}.solarized-light h2{border-bottom:1px solid #f6d784;line-height:1.7em}.solarized-light h6{color:#9c7600}.solarized-light hr{border:1px solid #fae7b3}.solarized-light pre>code{font-size:.9em;font-family:Consolas,Inconsolata,Courier,monospace}.solarized-light blockquote{border-left:4px solid #fae7b3;padding:0 15px;font-style:italic}.solarized-light table{background-color:#fdf4dd}.solarized-light table tr td,.solarized-light table tr th{border:1px solid #fae7b3}.solarized-light table tr:nth-child(2n){background-color:#fef8ea}.hljs{display:block;overflow-x:auto;padding:.5em;color:#dccf8f;background:url(./pojoaque.jpg) repeat scroll left top #181914;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-template_comment,.lisp .hljs-string{color:#586e75;font-style:italic}.clojure .hljs-title,.css .hljs-tag,.css .rule .hljs-keyword,.hljs-addition,.hljs-keyword,.hljs-winutils,.javascript .hljs-title,.method,.nginx .hljs-title{color:#b64926}.hljs-command,.hljs-hexcolor,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#468966}.clojure .hljs-built_in,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-function .hljs-title,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.lisp .hljs-title{color:#ffb03b}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-attribute{color:#b89859}.css .hljs-hexcolor,.css .hljs-number{color:#dccf8f}.css .hljs-class{color:#d3a60c}.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-important,.hljs-pi,.hljs-pragma,.hljs-preprocessor,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion{color:#dc322f}.tex .hljs-formula{background:#073642}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown solarized-light">

  <h5 id="1.-解压："><a name="1.-解压：" href="#1.-解压："></a>1. 解压：</h5><pre><code class="bash hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;Bash&quot;&gt;tar zxvf 文件名.tar.gz
&lt;/code&gt;&lt;/pre&gt;">tar zxvf 文件名.tar.gz
</code></pre><h5 id="2.-压缩："><a name="2.-压缩：" href="#2.-压缩："></a>2. 压缩：</h5><pre><code class="bash hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;Bash&quot;&gt;tar zcvf 文件名.tar.gz 目标名
&lt;/code&gt;&lt;/pre&gt;">tar zcvf 文件名.tar.gz 目标名
</code></pre><h5 id="3.-求某个文件的sha值："><a name="3.-求某个文件的sha值：" href="#3.-求某个文件的sha值："></a>3. 求某个文件的sha值：</h5><pre><code class="bash hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;Bash&quot;&gt;sha256sum odroid-xu3.tar.gz
&lt;/code&gt;&lt;/pre&gt;">sha256sum odroid-xu3.tar.gz
</code></pre><h5 id="4.-比对："><a name="4.-比对：" href="#4.-比对："></a>4. 比对：</h5><pre><code class="bash hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;Bash&quot;&gt;sha256sum 文件名
&lt;/code&gt;&lt;/pre&gt;">sha256sum 文件名
</code></pre><h5 id="5.-查看文件大小（目录下所有文件）："><a name="5.-查看文件大小（目录下所有文件）：" href="#5.-查看文件大小（目录下所有文件）："></a>5. 查看文件大小（目录下所有文件）：</h5><pre><code class="bash hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;Bash&quot;&gt;du -sh
&lt;/code&gt;&lt;/pre&gt;">du -sh
</code></pre><h5 id="6.-查看磁盘情况："><a name="6.-查看磁盘情况：" href="#6.-查看磁盘情况："></a>6. 查看磁盘情况：</h5><pre><code class="bash hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;Bash&quot;&gt;df -hl
&lt;/code&gt;&lt;/pre&gt;">df -hl
</code></pre><h5 id="7.-查看system.map中的符号信息的方法如下："><a name="7.-查看system.map中的符号信息的方法如下：" href="#7.-查看system.map中的符号信息的方法如下："></a>7. 查看System.map中的符号信息的方法如下：</h5><h6 id="第一种方法"><a name="第一种方法" href="#第一种方法"></a>第一种方法</h6><pre><code class="bash hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;Bash&quot;&gt;sudo cat /boot/System.map-$(uname -r) | grep &quot;vmap_area_list&quot;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-built_in">sudo</span> cat /boot/System.map-$(uname -r) | grep <span class="hljs-string">"vmap_area_list"</span>
</code></pre><h6 id="第二种方法"><a name="第二种方法" href="#第二种方法"></a>第二种方法</h6><pre><code class="bash hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;Bash&quot;&gt;cd /proc
sudo cat kallsyms | grep &quot;vmap_area_list&quot;
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-built_in">cd</span> /proc
<span class="hljs-built_in">sudo</span> cat kallsyms | grep <span class="hljs-string">"vmap_area_list"</span>
</code></pre><p><strong class="highlight">注意，在第二种方法中若是不加上sudo，输出的地址将全是0。</strong></p><h5 id="8.在内核编程中，要多使用list_for_each、list_for_each_entry等宏，它们都定义在内核链表表头中，在src/include/linux/list.h中，源码（2.6.24版本）如下："><a name="8.在内核编程中，要多使用list_for_each、list_for_each_entry等宏，它们都定义在内核链表表头中，在src/include/linux/list.h中，源码（2.6.24版本）如下：" href="#8.在内核编程中，要多使用list_for_each、list_for_each_entry等宏，它们都定义在内核链表表头中，在src/include/linux/list.h中，源码（2.6.24版本）如下："></a>8.在内核编程中，要多使用list_for_each、list_for_each_entry等宏，它们都定义在内核链表表头中，在src/include/linux/list.h中，源码（2.6.24版本）如下：</h5><pre><code class="c hljs" data-origin="&lt;pre&gt;&lt;code class=&quot;C&quot;&gt;#ifndef _LINUX_LIST_H
#define _LINUX_LIST_H

#ifdef __KERNEL__

#include &amp;lt;linux/stddef.h&amp;gt;
#include &amp;lt;linux/poison.h&amp;gt;
#include &amp;lt;linux/prefetch.h&amp;gt;
#include &amp;lt;asm/system.h&amp;gt;

/*
 * Simple doubly linked list implementation.
 *
 * Some of the internal functions (&quot;__xxx&quot;) are useful when
 * manipulating whole lists rather than single entries, as
 * sometimes we already know the next/prev entries and we can
 * generate better code by using them directly rather than
 * using the generic single-entry routines.
 */

struct list_head {
    struct list_head *next, *prev;
};

#define LIST_HEAD_INIT(name) { &amp;amp;(name), &amp;amp;(name) }

#define LIST_HEAD(name) \
    struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
    list-&amp;gt;next = list;
    list-&amp;gt;prev = list;
}

/*
 * Insert a new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
#ifndef CONFIG_DEBUG_LIST
static inline void __list_add(struct list_head *new,
                  struct list_head *prev,
                  struct list_head *next)
{
    next-&amp;gt;prev = new;
    new-&amp;gt;next = next;
    new-&amp;gt;prev = prev;
    prev-&amp;gt;next = new;
}
#else
extern void __list_add(struct list_head *new,
                  struct list_head *prev,
                  struct list_head *next);
#endif

/**
 * list_add - add a new entry
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void list_add(struct list_head *new, struct list_head *head)
{
    __list_add(new, head, head-&amp;gt;next);
}
#else
extern void list_add(struct list_head *new, struct list_head *head);
#endif


/**
 * list_add_tail - add a new entry
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
    __list_add(new, head-&amp;gt;prev, head);
}

/*
 * Insert a new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_add_rcu(struct list_head * new,
        struct list_head * prev, struct list_head * next)
{
    new-&amp;gt;next = next;
    new-&amp;gt;prev = prev;
    smp_wmb();
    next-&amp;gt;prev = new;
    prev-&amp;gt;next = new;
}

/**
 * list_add_rcu - add a new entry to rcu-protected list
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as list_add_rcu()
 * or list_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * list_for_each_entry_rcu().
 */
static inline void list_add_rcu(struct list_head *new, struct list_head *head)
{
    __list_add_rcu(new, head, head-&amp;gt;next);
}

/**
 * list_add_tail_rcu - add a new entry to rcu-protected list
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as list_add_tail_rcu()
 * or list_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * list_for_each_entry_rcu().
 */
static inline void list_add_tail_rcu(struct list_head *new,
                    struct list_head *head)
{
    __list_add_rcu(new, head-&amp;gt;prev, head);
}

/*
 * Delete a list entry by making the prev/next entries
 * point to each other.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head * prev, struct list_head * next)
{
    next-&amp;gt;prev = prev;
    prev-&amp;gt;next = next;
}

/**
 * list_del - deletes entry from list.
 * @entry: the element to delete from the list.
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
#ifndef CONFIG_DEBUG_LIST
static inline void list_del(struct list_head *entry)
{
    __list_del(entry-&amp;gt;prev, entry-&amp;gt;next);
    entry-&amp;gt;next = LIST_POISON1;
    entry-&amp;gt;prev = LIST_POISON2;
}
#else
extern void list_del(struct list_head *entry);
#endif

/**
 * list_del_rcu - deletes entry from list without re-initialization
 * @entry: the element to delete from the list.
 *
 * Note: list_empty() on entry does not return true after this,
 * the entry is in an undefined state. It is useful for RCU based
 * lockfree traversal.
 *
 * In particular, it means that we can not poison the forward
 * pointers that may still be used for walking the list.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as list_del_rcu()
 * or list_add_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * list_for_each_entry_rcu().
 *
 * Note that the caller is not permitted to immediately free
 * the newly deleted entry.  Instead, either synchronize_rcu()
 * or call_rcu() must be used to defer freeing until an RCU
 * grace period has elapsed.
 */
static inline void list_del_rcu(struct list_head *entry)
{
    __list_del(entry-&amp;gt;prev, entry-&amp;gt;next);
    entry-&amp;gt;prev = LIST_POISON2;
}

/**
 * list_replace - replace old entry by new one
 * @old : the element to be replaced
 * @new : the new element to insert
 *
 * If @old was empty, it will be overwritten.
 */
static inline void list_replace(struct list_head *old,
                struct list_head *new)
{
    new-&amp;gt;next = old-&amp;gt;next;
    new-&amp;gt;next-&amp;gt;prev = new;
    new-&amp;gt;prev = old-&amp;gt;prev;
    new-&amp;gt;prev-&amp;gt;next = new;
}

static inline void list_replace_init(struct list_head *old,
                    struct list_head *new)
{
    list_replace(old, new);
    INIT_LIST_HEAD(old);
}

/**
 * list_replace_rcu - replace old entry by new one
 * @old : the element to be replaced
 * @new : the new element to insert
 *
 * The @old entry will be replaced with the @new entry atomically.
 * Note: @old should not be empty.
 */
static inline void list_replace_rcu(struct list_head *old,
                struct list_head *new)
{
    new-&amp;gt;next = old-&amp;gt;next;
    new-&amp;gt;prev = old-&amp;gt;prev;
    smp_wmb();
    new-&amp;gt;next-&amp;gt;prev = new;
    new-&amp;gt;prev-&amp;gt;next = new;
    old-&amp;gt;prev = LIST_POISON2;
}

/**
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
static inline void list_del_init(struct list_head *entry)
{
    __list_del(entry-&amp;gt;prev, entry-&amp;gt;next);
    INIT_LIST_HEAD(entry);
}

/**
 * list_move - delete from one list and add as another's head
 * @list: the entry to move
 * @head: the head that will precede our entry
 */
static inline void list_move(struct list_head *list, struct list_head *head)
{
    __list_del(list-&amp;gt;prev, list-&amp;gt;next);
    list_add(list, head);
}

/**
 * list_move_tail - delete from one list and add as another's tail
 * @list: the entry to move
 * @head: the head that will follow our entry
 */
static inline void list_move_tail(struct list_head *list,
                  struct list_head *head)
{
    __list_del(list-&amp;gt;prev, list-&amp;gt;next);
    list_add_tail(list, head);
}

/**
 * list_is_last - tests whether @list is the last entry in list @head
 * @list: the entry to test
 * @head: the head of the list
 */
static inline int list_is_last(const struct list_head *list,
                const struct list_head *head)
{
    return list-&amp;gt;next == head;
}

/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
    return head-&amp;gt;next == head;
}

/**
 * list_empty_careful - tests whether a list is empty and not being modified
 * @head: the list to test
 *
 * Description:
 * tests whether a list is empty _and_ checks that no other CPU might be
 * in the process of modifying either member (next or prev)
 *
 * NOTE: using list_empty_careful() without synchronization
 * can only be safe if the only activity that can happen
 * to the list entry is list_del_init(). Eg. it cannot be used
 * if another CPU could re-list_add() it.
 */
static inline int list_empty_careful(const struct list_head *head)
{
    struct list_head *next = head-&amp;gt;next;
    return (next == head) &amp;amp;&amp;amp; (next == head-&amp;gt;prev);
}

static inline void __list_splice(struct list_head *list,
                 struct list_head *head)
{
    struct list_head *first = list-&amp;gt;next;
    struct list_head *last = list-&amp;gt;prev;
    struct list_head *at = head-&amp;gt;next;

    first-&amp;gt;prev = head;
    head-&amp;gt;next = first;

    last-&amp;gt;next = at;
    at-&amp;gt;prev = last;
}

/**
 * list_splice - join two lists
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 */
static inline void list_splice(struct list_head *list, struct list_head *head)
{
    if (!list_empty(list))
        __list_splice(list, head);
}

/**
 * list_splice_init - join two lists and reinitialise the emptied list.
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 *
 * The list at @list is reinitialised
 */
static inline void list_splice_init(struct list_head *list,
                    struct list_head *head)
{
    if (!list_empty(list)) {
        __list_splice(list, head);
        INIT_LIST_HEAD(list);
    }
}

/**
 * list_splice_init_rcu - splice an RCU-protected list into an existing list.
 * @list:    the RCU-protected list to splice
 * @head:    the place in the list to splice the first list into
 * @sync:    function to sync: synchronize_rcu(), synchronize_sched(), ...
 *
 * @head can be RCU-read traversed concurrently with this function.
 *
 * Note that this function blocks.
 *
 * Important note: the caller must take whatever action is necessary to
 *    prevent any other updates to @head.  In principle, it is possible
 *    to modify the list as soon as sync() begins execution.
 *    If this sort of thing becomes necessary, an alternative version
 *    based on call_rcu() could be created.  But only if -really-
 *    needed -- there is no shortage of RCU API members.
 */
static inline void list_splice_init_rcu(struct list_head *list,
                    struct list_head *head,
                    void (*sync)(void))
{
    struct list_head *first = list-&amp;gt;next;
    struct list_head *last = list-&amp;gt;prev;
    struct list_head *at = head-&amp;gt;next;

    if (list_empty(head))
        return;

    /* &quot;first&quot; and &quot;last&quot; tracking list, so initialize it. */

    INIT_LIST_HEAD(list);

    /*
     * At this point, the list body still points to the source list.
     * Wait for any readers to finish using the list before splicing
     * the list body into the new list.  Any new readers will see
     * an empty list.
     */

    sync();

    /*
     * Readers are finished with the source list, so perform splice.
     * The order is important if the new list is global and accessible
     * to concurrent RCU readers.  Note that RCU readers are not
     * permitted to traverse the prev pointers without excluding
     * this function.
     */

    last-&amp;gt;next = at;
    smp_wmb();
    head-&amp;gt;next = first;
    first-&amp;gt;prev = head;
    at-&amp;gt;prev = last;
}

/**
 * list_entry - get the struct for this entry
 * @ptr:    the &amp;amp;struct list_head pointer.
 * @type:    the type of the struct this is embedded in.
 * @member:    the name of the list_struct within the struct.
 */
#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)

/**
 * list_first_entry - get the first element from a list
 * @ptr:    the list head to take the element from.
 * @type:    the type of the struct this is embedded in.
 * @member:    the name of the list_struct within the struct.
 *
 * Note, that list is expected to be not empty.
 */
#define list_first_entry(ptr, type, member) \
    list_entry((ptr)-&amp;gt;next, type, member)

/**
 * list_for_each    -    iterate over a list
 * @pos:    the &amp;amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 */
#define list_for_each(pos, head) \
    for (pos = (head)-&amp;gt;next; prefetch(pos-&amp;gt;next), pos != (head); \
            pos = pos-&amp;gt;next)

/**
 * __list_for_each    -    iterate over a list
 * @pos:    the &amp;amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 *
 * This variant differs from list_for_each() in that it's the
 * simplest possible list iteration code, no prefetching is done.
 * Use this for code that knows the list to be very short (empty
 * or 1 entry) most of the time.
 */
#define __list_for_each(pos, head) \
    for (pos = (head)-&amp;gt;next; pos != (head); pos = pos-&amp;gt;next)

/**
 * list_for_each_prev    -    iterate over a list backwards
 * @pos:    the &amp;amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 */
#define list_for_each_prev(pos, head) \
    for (pos = (head)-&amp;gt;prev; prefetch(pos-&amp;gt;prev), pos != (head); \
            pos = pos-&amp;gt;prev)

/**
 * list_for_each_safe - iterate over a list safe against removal of list entry
 * @pos:    the &amp;amp;struct list_head to use as a loop cursor.
 * @n:        another &amp;amp;struct list_head to use as temporary storage
 * @head:    the head for your list.
 */
#define list_for_each_safe(pos, n, head) \
    for (pos = (head)-&amp;gt;next, n = pos-&amp;gt;next; pos != (head); \
        pos = n, n = pos-&amp;gt;next)

/**
 * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry
 * @pos:    the &amp;amp;struct list_head to use as a loop cursor.
 * @n:        another &amp;amp;struct list_head to use as temporary storage
 * @head:    the head for your list.
 */
#define list_for_each_prev_safe(pos, n, head) \
    for (pos = (head)-&amp;gt;prev, n = pos-&amp;gt;prev; \
         prefetch(pos-&amp;gt;prev), pos != (head); \
         pos = n, n = pos-&amp;gt;prev)

/**
 * list_for_each_entry    -    iterate over list of given type
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 */
#define list_for_each_entry(pos, head, member)                \
    for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member);    \
         prefetch(pos-&amp;gt;member.next), &amp;amp;pos-&amp;gt;member != (head);     \
         pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))

/**
 * list_for_each_entry_reverse - iterate backwards over list of given type.
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 */
#define list_for_each_entry_reverse(pos, head, member)            \
    for (pos = list_entry((head)-&amp;gt;prev, typeof(*pos), member);    \
         prefetch(pos-&amp;gt;member.prev), &amp;amp;pos-&amp;gt;member != (head);     \
         pos = list_entry(pos-&amp;gt;member.prev, typeof(*pos), member))

/**
 * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()
 * @pos:    the type * to use as a start point
 * @head:    the head of the list
 * @member:    the name of the list_struct within the struct.
 *
 * Prepares a pos entry for use as a start point in list_for_each_entry_continue().
 */
#define list_prepare_entry(pos, head, member) \
    ((pos) ? : list_entry(head, typeof(*pos), member))

/**
 * list_for_each_entry_continue - continue iteration over list of given type
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Continue to iterate over list of given type, continuing after
 * the current position.
 */
#define list_for_each_entry_continue(pos, head, member)         \
    for (pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member);    \
         prefetch(pos-&amp;gt;member.next), &amp;amp;pos-&amp;gt;member != (head);    \
         pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))

/**
 * list_for_each_entry_continue_reverse - iterate backwards from the given point
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Start to iterate over list of given type backwards, continuing after
 * the current position.
 */
#define list_for_each_entry_continue_reverse(pos, head, member)        \
    for (pos = list_entry(pos-&amp;gt;member.prev, typeof(*pos), member);    \
         prefetch(pos-&amp;gt;member.prev), &amp;amp;pos-&amp;gt;member != (head);    \
         pos = list_entry(pos-&amp;gt;member.prev, typeof(*pos), member))

/**
 * list_for_each_entry_from - iterate over list of given type from the current point
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Iterate over list of given type, continuing from current position.
 */
#define list_for_each_entry_from(pos, head, member)             \
    for (; prefetch(pos-&amp;gt;member.next), &amp;amp;pos-&amp;gt;member != (head);    \
         pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))

/**
 * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 */
#define list_for_each_entry_safe(pos, n, head, member)            \
    for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member),    \
        n = list_entry(pos-&amp;gt;member.next, typeof(*pos), member);    \
         &amp;amp;pos-&amp;gt;member != (head);                     \
         pos = n, n = list_entry(n-&amp;gt;member.next, typeof(*n), member))

/**
 * list_for_each_entry_safe_continue
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Iterate over list of given type, continuing after current point,
 * safe against removal of list entry.
 */
#define list_for_each_entry_safe_continue(pos, n, head, member)         \
    for (pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member),         \
        n = list_entry(pos-&amp;gt;member.next, typeof(*pos), member);        \
         &amp;amp;pos-&amp;gt;member != (head);                        \
         pos = n, n = list_entry(n-&amp;gt;member.next, typeof(*n), member))

/**
 * list_for_each_entry_safe_from
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Iterate over list of given type from current point, safe against
 * removal of list entry.
 */
#define list_for_each_entry_safe_from(pos, n, head, member)             \
    for (n = list_entry(pos-&amp;gt;member.next, typeof(*pos), member);        \
         &amp;amp;pos-&amp;gt;member != (head);                        \
         pos = n, n = list_entry(n-&amp;gt;member.next, typeof(*n), member))

/**
 * list_for_each_entry_safe_reverse
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Iterate backwards over list of given type, safe against removal
 * of list entry.
 */
#define list_for_each_entry_safe_reverse(pos, n, head, member)        \
    for (pos = list_entry((head)-&amp;gt;prev, typeof(*pos), member),    \
        n = list_entry(pos-&amp;gt;member.prev, typeof(*pos), member);    \
         &amp;amp;pos-&amp;gt;member != (head);                     \
         pos = n, n = list_entry(n-&amp;gt;member.prev, typeof(*n), member))

/**
 * list_for_each_rcu    -    iterate over an rcu-protected list
 * @pos:    the &amp;amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as list_add_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */
#define list_for_each_rcu(pos, head) \
    for (pos = (head)-&amp;gt;next; \
        prefetch(rcu_dereference(pos)-&amp;gt;next), pos != (head); \
            pos = pos-&amp;gt;next)

#define __list_for_each_rcu(pos, head) \
    for (pos = (head)-&amp;gt;next; \
        rcu_dereference(pos) != (head); \
            pos = pos-&amp;gt;next)

/**
 * list_for_each_safe_rcu
 * @pos:    the &amp;amp;struct list_head to use as a loop cursor.
 * @n:        another &amp;amp;struct list_head to use as temporary storage
 * @head:    the head for your list.
 *
 * Iterate over an rcu-protected list, safe against removal of list entry.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as list_add_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */
#define list_for_each_safe_rcu(pos, n, head) \
    for (pos = (head)-&amp;gt;next; \
        n = rcu_dereference(pos)-&amp;gt;next, pos != (head); \
        pos = n)

/**
 * list_for_each_entry_rcu    -    iterate over rcu list of given type
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as list_add_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */
#define list_for_each_entry_rcu(pos, head, member) \
    for (pos = list_entry((head)-&amp;gt;next, typeof(*pos), member); \
        prefetch(rcu_dereference(pos)-&amp;gt;member.next), \
            &amp;amp;pos-&amp;gt;member != (head); \
        pos = list_entry(pos-&amp;gt;member.next, typeof(*pos), member))


/**
 * list_for_each_continue_rcu
 * @pos:    the &amp;amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 *
 * Iterate over an rcu-protected list, continuing after current point.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as list_add_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */
#define list_for_each_continue_rcu(pos, head) \
    for ((pos) = (pos)-&amp;gt;next; \
        prefetch(rcu_dereference((pos))-&amp;gt;next), (pos) != (head); \
            (pos) = (pos)-&amp;gt;next)

/*
 * Double linked lists with a single pointer list head.
 * Mostly useful for hash tables where the two pointer list head is
 * too wasteful.
 * You lose the ability to access the tail in O(1).
 */

struct hlist_head {
    struct hlist_node *first;
};

struct hlist_node {
    struct hlist_node *next, **pprev;
};

#define HLIST_HEAD_INIT { .first = NULL }
#define HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }
#define INIT_HLIST_HEAD(ptr) ((ptr)-&amp;gt;first = NULL)
static inline void INIT_HLIST_NODE(struct hlist_node *h)
{
    h-&amp;gt;next = NULL;
    h-&amp;gt;pprev = NULL;
}

static inline int hlist_unhashed(const struct hlist_node *h)
{
    return !h-&amp;gt;pprev;
}

static inline int hlist_empty(const struct hlist_head *h)
{
    return !h-&amp;gt;first;
}

static inline void __hlist_del(struct hlist_node *n)
{
    struct hlist_node *next = n-&amp;gt;next;
    struct hlist_node **pprev = n-&amp;gt;pprev;
    *pprev = next;
    if (next)
        next-&amp;gt;pprev = pprev;
}

static inline void hlist_del(struct hlist_node *n)
{
    __hlist_del(n);
    n-&amp;gt;next = LIST_POISON1;
    n-&amp;gt;pprev = LIST_POISON2;
}

/**
 * hlist_del_rcu - deletes entry from hash list without re-initialization
 * @n: the element to delete from the hash list.
 *
 * Note: list_unhashed() on entry does not return true after this,
 * the entry is in an undefined state. It is useful for RCU based
 * lockfree traversal.
 *
 * In particular, it means that we can not poison the forward
 * pointers that may still be used for walking the hash list.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_add_head_rcu()
 * or hlist_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_for_each_entry().
 */
static inline void hlist_del_rcu(struct hlist_node *n)
{
    __hlist_del(n);
    n-&amp;gt;pprev = LIST_POISON2;
}

static inline void hlist_del_init(struct hlist_node *n)
{
    if (!hlist_unhashed(n)) {
        __hlist_del(n);
        INIT_HLIST_NODE(n);
    }
}

/**
 * hlist_replace_rcu - replace old entry by new one
 * @old : the element to be replaced
 * @new : the new element to insert
 *
 * The @old entry will be replaced with the @new entry atomically.
 */
static inline void hlist_replace_rcu(struct hlist_node *old,
                    struct hlist_node *new)
{
    struct hlist_node *next = old-&amp;gt;next;

    new-&amp;gt;next = next;
    new-&amp;gt;pprev = old-&amp;gt;pprev;
    smp_wmb();
    if (next)
        new-&amp;gt;next-&amp;gt;pprev = &amp;amp;new-&amp;gt;next;
    *new-&amp;gt;pprev = new;
    old-&amp;gt;pprev = LIST_POISON2;
}

static inline void hlist_add_head(struct hlist_node *n, struct hlist_head *h)
{
    struct hlist_node *first = h-&amp;gt;first;
    n-&amp;gt;next = first;
    if (first)
        first-&amp;gt;pprev = &amp;amp;n-&amp;gt;next;
    h-&amp;gt;first = n;
    n-&amp;gt;pprev = &amp;amp;h-&amp;gt;first;
}


/**
 * hlist_add_head_rcu
 * @n: the element to add to the hash list.
 * @h: the list to add to.
 *
 * Description:
 * Adds the specified element to the specified hlist,
 * while permitting racing traversals.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_add_head_rcu()
 * or hlist_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_for_each_entry_rcu(), used to prevent memory-consistency
 * problems on Alpha CPUs.  Regardless of the type of CPU, the
 * list-traversal primitive must be guarded by rcu_read_lock().
 */
static inline void hlist_add_head_rcu(struct hlist_node *n,
                    struct hlist_head *h)
{
    struct hlist_node *first = h-&amp;gt;first;
    n-&amp;gt;next = first;
    n-&amp;gt;pprev = &amp;amp;h-&amp;gt;first;
    smp_wmb();
    if (first)
        first-&amp;gt;pprev = &amp;amp;n-&amp;gt;next;
    h-&amp;gt;first = n;
}

/* next must be != NULL */
static inline void hlist_add_before(struct hlist_node *n,
                    struct hlist_node *next)
{
    n-&amp;gt;pprev = next-&amp;gt;pprev;
    n-&amp;gt;next = next;
    next-&amp;gt;pprev = &amp;amp;n-&amp;gt;next;
    *(n-&amp;gt;pprev) = n;
}

static inline void hlist_add_after(struct hlist_node *n,
                    struct hlist_node *next)
{
    next-&amp;gt;next = n-&amp;gt;next;
    n-&amp;gt;next = next;
    next-&amp;gt;pprev = &amp;amp;n-&amp;gt;next;

    if(next-&amp;gt;next)
        next-&amp;gt;next-&amp;gt;pprev  = &amp;amp;next-&amp;gt;next;
}

/**
 * hlist_add_before_rcu
 * @n: the new element to add to the hash list.
 * @next: the existing element to add the new element before.
 *
 * Description:
 * Adds the specified element to the specified hlist
 * before the specified node while permitting racing traversals.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_add_head_rcu()
 * or hlist_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_for_each_entry_rcu(), used to prevent memory-consistency
 * problems on Alpha CPUs.
 */
static inline void hlist_add_before_rcu(struct hlist_node *n,
                    struct hlist_node *next)
{
    n-&amp;gt;pprev = next-&amp;gt;pprev;
    n-&amp;gt;next = next;
    smp_wmb();
    next-&amp;gt;pprev = &amp;amp;n-&amp;gt;next;
    *(n-&amp;gt;pprev) = n;
}

/**
 * hlist_add_after_rcu
 * @prev: the existing element to add the new element after.
 * @n: the new element to add to the hash list.
 *
 * Description:
 * Adds the specified element to the specified hlist
 * after the specified node while permitting racing traversals.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_add_head_rcu()
 * or hlist_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_for_each_entry_rcu(), used to prevent memory-consistency
 * problems on Alpha CPUs.
 */
static inline void hlist_add_after_rcu(struct hlist_node *prev,
                       struct hlist_node *n)
{
    n-&amp;gt;next = prev-&amp;gt;next;
    n-&amp;gt;pprev = &amp;amp;prev-&amp;gt;next;
    smp_wmb();
    prev-&amp;gt;next = n;
    if (n-&amp;gt;next)
        n-&amp;gt;next-&amp;gt;pprev = &amp;amp;n-&amp;gt;next;
}

#define hlist_entry(ptr, type, member) container_of(ptr,type,member)

#define hlist_for_each(pos, head) \
    for (pos = (head)-&amp;gt;first; pos &amp;amp;&amp;amp; ({ prefetch(pos-&amp;gt;next); 1; }); \
         pos = pos-&amp;gt;next)

#define hlist_for_each_safe(pos, n, head) \
    for (pos = (head)-&amp;gt;first; pos &amp;amp;&amp;amp; ({ n = pos-&amp;gt;next; 1; }); \
         pos = n)

/**
 * hlist_for_each_entry    - iterate over list of given type
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;amp;struct hlist_node to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(tpos, pos, head, member)             \
    for (pos = (head)-&amp;gt;first;                     \
         pos &amp;amp;&amp;amp; ({ prefetch(pos-&amp;gt;next); 1;}) &amp;amp;&amp;amp;             \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
         pos = pos-&amp;gt;next)

/**
 * hlist_for_each_entry_continue - iterate over a hlist continuing after current point
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;amp;struct hlist_node to use as a loop cursor.
 * @member:    the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_continue(tpos, pos, member)         \
    for (pos = (pos)-&amp;gt;next;                         \
         pos &amp;amp;&amp;amp; ({ prefetch(pos-&amp;gt;next); 1;}) &amp;amp;&amp;amp;             \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
         pos = pos-&amp;gt;next)

/**
 * hlist_for_each_entry_from - iterate over a hlist continuing from current point
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;amp;struct hlist_node to use as a loop cursor.
 * @member:    the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_from(tpos, pos, member)             \
    for (; pos &amp;amp;&amp;amp; ({ prefetch(pos-&amp;gt;next); 1;}) &amp;amp;&amp;amp;             \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
         pos = pos-&amp;gt;next)

/**
 * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;amp;struct hlist_node to use as a loop cursor.
 * @n:        another &amp;amp;struct hlist_node to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry_safe(tpos, pos, n, head, member)          \
    for (pos = (head)-&amp;gt;first;                     \
         pos &amp;amp;&amp;amp; ({ n = pos-&amp;gt;next; 1; }) &amp;amp;&amp;amp;                  \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
         pos = n)

/**
 * hlist_for_each_entry_rcu - iterate over rcu list of given type
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;amp;struct hlist_node to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the hlist_node within the struct.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as hlist_add_head_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */
#define hlist_for_each_entry_rcu(tpos, pos, head, member)         \
    for (pos = (head)-&amp;gt;first;                     \
         rcu_dereference(pos) &amp;amp;&amp;amp; ({ prefetch(pos-&amp;gt;next); 1;}) &amp;amp;&amp;amp;     \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); 1;}); \
         pos = pos-&amp;gt;next)

#else
#warning &quot;don't include kernel headers in userspace&quot;
#endif /* __KERNEL__ */
#endif
&lt;/code&gt;&lt;/pre&gt;"><span class="hljs-preprocessor">#ifndef _LINUX_LIST_H</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> _LINUX_LIST_H</span>

<span class="hljs-preprocessor">#ifdef __KERNEL__</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;linux/stddef.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;linux/poison.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;linux/prefetch.h&gt;</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">include</span> &lt;asm/system.h&gt;</span>

<span class="hljs-comment">/*
 * Simple doubly linked list implementation.
 *
 * Some of the internal functions ("__xxx") are useful when
 * manipulating whole lists rather than single entries, as
 * sometimes we already know the next/prev entries and we can
 * generate better code by using them directly rather than
 * using the generic single-entry routines.
 */</span>

<span class="hljs-keyword">struct</span> list_head {
    <span class="hljs-keyword">struct</span> list_head *next, *prev;
};

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) }</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> LIST_HEAD(name) \</span>
    <span class="hljs-keyword">struct</span> list_head name = LIST_HEAD_INIT(name)

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> INIT_LIST_HEAD(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>)
{
    <span class="hljs-built_in">list</span>-&gt;next = <span class="hljs-built_in">list</span>;
    <span class="hljs-built_in">list</span>-&gt;prev = <span class="hljs-built_in">list</span>;
}

<span class="hljs-comment">/*
 * Insert a new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */</span>
<span class="hljs-preprocessor">#ifndef CONFIG_DEBUG_LIST</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __list_add(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>,
                  <span class="hljs-keyword">struct</span> list_head *prev,
                  <span class="hljs-keyword">struct</span> list_head *next)
{
    next-&gt;prev = <span class="hljs-keyword">new</span>;
    <span class="hljs-keyword">new</span>-&gt;next = next;
    <span class="hljs-keyword">new</span>-&gt;prev = prev;
    prev-&gt;next = <span class="hljs-keyword">new</span>;
}
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> __list_add(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>,
                  <span class="hljs-keyword">struct</span> list_head *prev,
                  <span class="hljs-keyword">struct</span> list_head *next);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">/**
 * list_add - add a new entry
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */</span>
<span class="hljs-preprocessor">#ifndef CONFIG_DEBUG_LIST</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_add(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>, <span class="hljs-keyword">struct</span> list_head *head)
{
    __list_add(<span class="hljs-keyword">new</span>, head, head-&gt;next);
}
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> list_add(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>, <span class="hljs-keyword">struct</span> list_head *head);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>


<span class="hljs-comment">/**
 * list_add_tail - add a new entry
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_add_tail(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>, <span class="hljs-keyword">struct</span> list_head *head)
{
    __list_add(<span class="hljs-keyword">new</span>, head-&gt;prev, head);
}

<span class="hljs-comment">/*
 * Insert a new entry between two known consecutive entries.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __list_add_rcu(<span class="hljs-keyword">struct</span> list_head * <span class="hljs-keyword">new</span>,
        <span class="hljs-keyword">struct</span> list_head * prev, <span class="hljs-keyword">struct</span> list_head * next)
{
    <span class="hljs-keyword">new</span>-&gt;next = next;
    <span class="hljs-keyword">new</span>-&gt;prev = prev;
    smp_wmb();
    next-&gt;prev = <span class="hljs-keyword">new</span>;
    prev-&gt;next = <span class="hljs-keyword">new</span>;
}

<span class="hljs-comment">/**
 * list_add_rcu - add a new entry to rcu-protected list
 * @new: new entry to be added
 * @head: list head to add it after
 *
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as list_add_rcu()
 * or list_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * list_for_each_entry_rcu().
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_add_rcu(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>, <span class="hljs-keyword">struct</span> list_head *head)
{
    __list_add_rcu(<span class="hljs-keyword">new</span>, head, head-&gt;next);
}

<span class="hljs-comment">/**
 * list_add_tail_rcu - add a new entry to rcu-protected list
 * @new: new entry to be added
 * @head: list head to add it before
 *
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as list_add_tail_rcu()
 * or list_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * list_for_each_entry_rcu().
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_add_tail_rcu(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>,
                    <span class="hljs-keyword">struct</span> list_head *head)
{
    __list_add_rcu(<span class="hljs-keyword">new</span>, head-&gt;prev, head);
}

<span class="hljs-comment">/*
 * Delete a list entry by making the prev/next entries
 * point to each other.
 *
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __list_del(<span class="hljs-keyword">struct</span> list_head * prev, <span class="hljs-keyword">struct</span> list_head * next)
{
    next-&gt;prev = prev;
    prev-&gt;next = next;
}

<span class="hljs-comment">/**
 * list_del - deletes entry from list.
 * @entry: the element to delete from the list.
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */</span>
<span class="hljs-preprocessor">#ifndef CONFIG_DEBUG_LIST</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_del(<span class="hljs-keyword">struct</span> list_head *entry)
{
    __list_del(entry-&gt;prev, entry-&gt;next);
    entry-&gt;next = LIST_POISON1;
    entry-&gt;prev = LIST_POISON2;
}
<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> list_del(<span class="hljs-keyword">struct</span> list_head *entry);
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-comment">/**
 * list_del_rcu - deletes entry from list without re-initialization
 * @entry: the element to delete from the list.
 *
 * Note: list_empty() on entry does not return true after this,
 * the entry is in an undefined state. It is useful for RCU based
 * lockfree traversal.
 *
 * In particular, it means that we can not poison the forward
 * pointers that may still be used for walking the list.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as list_del_rcu()
 * or list_add_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * list_for_each_entry_rcu().
 *
 * Note that the caller is not permitted to immediately free
 * the newly deleted entry.  Instead, either synchronize_rcu()
 * or call_rcu() must be used to defer freeing until an RCU
 * grace period has elapsed.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_del_rcu(<span class="hljs-keyword">struct</span> list_head *entry)
{
    __list_del(entry-&gt;prev, entry-&gt;next);
    entry-&gt;prev = LIST_POISON2;
}

<span class="hljs-comment">/**
 * list_replace - replace old entry by new one
 * @old : the element to be replaced
 * @new : the new element to insert
 *
 * If @old was empty, it will be overwritten.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_replace(<span class="hljs-keyword">struct</span> list_head *old,
                <span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>)
{
    <span class="hljs-keyword">new</span>-&gt;next = old-&gt;next;
    <span class="hljs-keyword">new</span>-&gt;next-&gt;prev = <span class="hljs-keyword">new</span>;
    <span class="hljs-keyword">new</span>-&gt;prev = old-&gt;prev;
    <span class="hljs-keyword">new</span>-&gt;prev-&gt;next = <span class="hljs-keyword">new</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_replace_init(<span class="hljs-keyword">struct</span> list_head *old,
                    <span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>)
{
    list_replace(old, <span class="hljs-keyword">new</span>);
    INIT_LIST_HEAD(old);
}

<span class="hljs-comment">/**
 * list_replace_rcu - replace old entry by new one
 * @old : the element to be replaced
 * @new : the new element to insert
 *
 * The @old entry will be replaced with the @new entry atomically.
 * Note: @old should not be empty.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_replace_rcu(<span class="hljs-keyword">struct</span> list_head *old,
                <span class="hljs-keyword">struct</span> list_head *<span class="hljs-keyword">new</span>)
{
    <span class="hljs-keyword">new</span>-&gt;next = old-&gt;next;
    <span class="hljs-keyword">new</span>-&gt;prev = old-&gt;prev;
    smp_wmb();
    <span class="hljs-keyword">new</span>-&gt;next-&gt;prev = <span class="hljs-keyword">new</span>;
    <span class="hljs-keyword">new</span>-&gt;prev-&gt;next = <span class="hljs-keyword">new</span>;
    old-&gt;prev = LIST_POISON2;
}

<span class="hljs-comment">/**
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_del_init(<span class="hljs-keyword">struct</span> list_head *entry)
{
    __list_del(entry-&gt;prev, entry-&gt;next);
    INIT_LIST_HEAD(entry);
}

<span class="hljs-comment">/**
 * list_move - delete from one list and add as another's head
 * @list: the entry to move
 * @head: the head that will precede our entry
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_move(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> list_head *head)
{
    __list_del(<span class="hljs-built_in">list</span>-&gt;prev, <span class="hljs-built_in">list</span>-&gt;next);
    list_add(<span class="hljs-built_in">list</span>, head);
}

<span class="hljs-comment">/**
 * list_move_tail - delete from one list and add as another's tail
 * @list: the entry to move
 * @head: the head that will follow our entry
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_move_tail(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,
                  <span class="hljs-keyword">struct</span> list_head *head)
{
    __list_del(<span class="hljs-built_in">list</span>-&gt;prev, <span class="hljs-built_in">list</span>-&gt;next);
    list_add_tail(<span class="hljs-built_in">list</span>, head);
}

<span class="hljs-comment">/**
 * list_is_last - tests whether @list is the last entry in list @head
 * @list: the entry to test
 * @head: the head of the list
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> list_is_last(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,
                <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> list_head *head)
{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>-&gt;next == head;
}

<span class="hljs-comment">/**
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> list_empty(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> list_head *head)
{
    <span class="hljs-keyword">return</span> head-&gt;next == head;
}

<span class="hljs-comment">/**
 * list_empty_careful - tests whether a list is empty and not being modified
 * @head: the list to test
 *
 * Description:
 * tests whether a list is empty _and_ checks that no other CPU might be
 * in the process of modifying either member (next or prev)
 *
 * NOTE: using list_empty_careful() without synchronization
 * can only be safe if the only activity that can happen
 * to the list entry is list_del_init(). Eg. it cannot be used
 * if another CPU could re-list_add() it.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> list_empty_careful(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> list_head *head)
{
    <span class="hljs-keyword">struct</span> list_head *next = head-&gt;next;
    <span class="hljs-keyword">return</span> (next == head) &amp;&amp; (next == head-&gt;prev);
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __list_splice(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,
                 <span class="hljs-keyword">struct</span> list_head *head)
{
    <span class="hljs-keyword">struct</span> list_head *first = <span class="hljs-built_in">list</span>-&gt;next;
    <span class="hljs-keyword">struct</span> list_head *last = <span class="hljs-built_in">list</span>-&gt;prev;
    <span class="hljs-keyword">struct</span> list_head *at = head-&gt;next;

    first-&gt;prev = head;
    head-&gt;next = first;

    last-&gt;next = at;
    at-&gt;prev = last;
}

<span class="hljs-comment">/**
 * list_splice - join two lists
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_splice(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>, <span class="hljs-keyword">struct</span> list_head *head)
{
    <span class="hljs-keyword">if</span> (!list_empty(<span class="hljs-built_in">list</span>))
        __list_splice(<span class="hljs-built_in">list</span>, head);
}

<span class="hljs-comment">/**
 * list_splice_init - join two lists and reinitialise the emptied list.
 * @list: the new list to add.
 * @head: the place to add it in the first list.
 *
 * The list at @list is reinitialised
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_splice_init(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,
                    <span class="hljs-keyword">struct</span> list_head *head)
{
    <span class="hljs-keyword">if</span> (!list_empty(<span class="hljs-built_in">list</span>)) {
        __list_splice(<span class="hljs-built_in">list</span>, head);
        INIT_LIST_HEAD(<span class="hljs-built_in">list</span>);
    }
}

<span class="hljs-comment">/**
 * list_splice_init_rcu - splice an RCU-protected list into an existing list.
 * @list:    the RCU-protected list to splice
 * @head:    the place in the list to splice the first list into
 * @sync:    function to sync: synchronize_rcu(), synchronize_sched(), ...
 *
 * @head can be RCU-read traversed concurrently with this function.
 *
 * Note that this function blocks.
 *
 * Important note: the caller must take whatever action is necessary to
 *    prevent any other updates to @head.  In principle, it is possible
 *    to modify the list as soon as sync() begins execution.
 *    If this sort of thing becomes necessary, an alternative version
 *    based on call_rcu() could be created.  But only if -really-
 *    needed -- there is no shortage of RCU API members.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> list_splice_init_rcu(<span class="hljs-keyword">struct</span> list_head *<span class="hljs-built_in">list</span>,
                    <span class="hljs-keyword">struct</span> list_head *head,
                    <span class="hljs-keyword">void</span> (*sync)(<span class="hljs-keyword">void</span>))
{
    <span class="hljs-keyword">struct</span> list_head *first = <span class="hljs-built_in">list</span>-&gt;next;
    <span class="hljs-keyword">struct</span> list_head *last = <span class="hljs-built_in">list</span>-&gt;prev;
    <span class="hljs-keyword">struct</span> list_head *at = head-&gt;next;

    <span class="hljs-keyword">if</span> (list_empty(head))
        <span class="hljs-keyword">return</span>;

    <span class="hljs-comment">/* "first" and "last" tracking list, so initialize it. */</span>

    INIT_LIST_HEAD(<span class="hljs-built_in">list</span>);

    <span class="hljs-comment">/*
     * At this point, the list body still points to the source list.
     * Wait for any readers to finish using the list before splicing
     * the list body into the new list.  Any new readers will see
     * an empty list.
     */</span>

    sync();

    <span class="hljs-comment">/*
     * Readers are finished with the source list, so perform splice.
     * The order is important if the new list is global and accessible
     * to concurrent RCU readers.  Note that RCU readers are not
     * permitted to traverse the prev pointers without excluding
     * this function.
     */</span>

    last-&gt;next = at;
    smp_wmb();
    head-&gt;next = first;
    first-&gt;prev = head;
    at-&gt;prev = last;
}

<span class="hljs-comment">/**
 * list_entry - get the struct for this entry
 * @ptr:    the &amp;struct list_head pointer.
 * @type:    the type of the struct this is embedded in.
 * @member:    the name of the list_struct within the struct.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_entry(ptr, type, member) \</span>
    container_of(ptr, type, member)

<span class="hljs-comment">/**
 * list_first_entry - get the first element from a list
 * @ptr:    the list head to take the element from.
 * @type:    the type of the struct this is embedded in.
 * @member:    the name of the list_struct within the struct.
 *
 * Note, that list is expected to be not empty.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_first_entry(ptr, type, member) \</span>
    list_entry((ptr)-&gt;next, type, member)

<span class="hljs-comment">/**
 * list_for_each    -    iterate over a list
 * @pos:    the &amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each(pos, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;next; prefetch(pos-&gt;next), pos != (head); \
            pos = pos-&gt;next)

<span class="hljs-comment">/**
 * __list_for_each    -    iterate over a list
 * @pos:    the &amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 *
 * This variant differs from list_for_each() in that it's the
 * simplest possible list iteration code, no prefetching is done.
 * Use this for code that knows the list to be very short (empty
 * or 1 entry) most of the time.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> __list_for_each(pos, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)

<span class="hljs-comment">/**
 * list_for_each_prev    -    iterate over a list backwards
 * @pos:    the &amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_prev(pos, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;prev; prefetch(pos-&gt;prev), pos != (head); \
            pos = pos-&gt;prev)

<span class="hljs-comment">/**
 * list_for_each_safe - iterate over a list safe against removal of list entry
 * @pos:    the &amp;struct list_head to use as a loop cursor.
 * @n:        another &amp;struct list_head to use as temporary storage
 * @head:    the head for your list.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_safe(pos, n, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;next, n = pos-&gt;next; pos != (head); \
        pos = n, n = pos-&gt;next)

<span class="hljs-comment">/**
 * list_for_each_prev_safe - iterate over a list backwards safe against removal of list entry
 * @pos:    the &amp;struct list_head to use as a loop cursor.
 * @n:        another &amp;struct list_head to use as temporary storage
 * @head:    the head for your list.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_prev_safe(pos, n, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;prev, n = pos-&gt;prev; \
         prefetch(pos-&gt;prev), pos != (head); \
         pos = n, n = pos-&gt;prev)

<span class="hljs-comment">/**
 * list_for_each_entry    -    iterate over list of given type
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry(pos, head, member)                \</span>
    <span class="hljs-keyword">for</span> (pos = list_entry((head)-&gt;next, typeof(*pos), member);    \
         prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);     \
         pos = list_entry(pos-&gt;member.next, typeof(*pos), member))

<span class="hljs-comment">/**
 * list_for_each_entry_reverse - iterate backwards over list of given type.
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_reverse(pos, head, member)            \</span>
    <span class="hljs-keyword">for</span> (pos = list_entry((head)-&gt;prev, typeof(*pos), member);    \
         prefetch(pos-&gt;member.prev), &amp;pos-&gt;member != (head);     \
         pos = list_entry(pos-&gt;member.prev, typeof(*pos), member))

<span class="hljs-comment">/**
 * list_prepare_entry - prepare a pos entry for use in list_for_each_entry_continue()
 * @pos:    the type * to use as a start point
 * @head:    the head of the list
 * @member:    the name of the list_struct within the struct.
 *
 * Prepares a pos entry for use as a start point in list_for_each_entry_continue().
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_prepare_entry(pos, head, member) \</span>
    ((pos) ? : list_entry(head, typeof(*pos), member))

<span class="hljs-comment">/**
 * list_for_each_entry_continue - continue iteration over list of given type
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Continue to iterate over list of given type, continuing after
 * the current position.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_continue(pos, head, member)         \</span>
    <span class="hljs-keyword">for</span> (pos = list_entry(pos-&gt;member.next, typeof(*pos), member);    \
         prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);    \
         pos = list_entry(pos-&gt;member.next, typeof(*pos), member))

<span class="hljs-comment">/**
 * list_for_each_entry_continue_reverse - iterate backwards from the given point
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Start to iterate over list of given type backwards, continuing after
 * the current position.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_continue_reverse(pos, head, member)        \</span>
    <span class="hljs-keyword">for</span> (pos = list_entry(pos-&gt;member.prev, typeof(*pos), member);    \
         prefetch(pos-&gt;member.prev), &amp;pos-&gt;member != (head);    \
         pos = list_entry(pos-&gt;member.prev, typeof(*pos), member))

<span class="hljs-comment">/**
 * list_for_each_entry_from - iterate over list of given type from the current point
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Iterate over list of given type, continuing from current position.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_from(pos, head, member)             \</span>
    <span class="hljs-keyword">for</span> (; prefetch(pos-&gt;member.next), &amp;pos-&gt;member != (head);    \
         pos = list_entry(pos-&gt;member.next, typeof(*pos), member))

<span class="hljs-comment">/**
 * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_safe(pos, n, head, member)            \</span>
    <span class="hljs-keyword">for</span> (pos = list_entry((head)-&gt;next, typeof(*pos), member),    \
        n = list_entry(pos-&gt;member.next, typeof(*pos), member);    \
         &amp;pos-&gt;member != (head);                     \
         pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))

<span class="hljs-comment">/**
 * list_for_each_entry_safe_continue
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Iterate over list of given type, continuing after current point,
 * safe against removal of list entry.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_safe_continue(pos, n, head, member)         \</span>
    <span class="hljs-keyword">for</span> (pos = list_entry(pos-&gt;member.next, typeof(*pos), member),         \
        n = list_entry(pos-&gt;member.next, typeof(*pos), member);        \
         &amp;pos-&gt;member != (head);                        \
         pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))

<span class="hljs-comment">/**
 * list_for_each_entry_safe_from
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Iterate over list of given type from current point, safe against
 * removal of list entry.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_safe_from(pos, n, head, member)             \</span>
    <span class="hljs-keyword">for</span> (n = list_entry(pos-&gt;member.next, typeof(*pos), member);        \
         &amp;pos-&gt;member != (head);                        \
         pos = n, n = list_entry(n-&gt;member.next, typeof(*n), member))

<span class="hljs-comment">/**
 * list_for_each_entry_safe_reverse
 * @pos:    the type * to use as a loop cursor.
 * @n:        another type * to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * Iterate backwards over list of given type, safe against removal
 * of list entry.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_safe_reverse(pos, n, head, member)        \</span>
    <span class="hljs-keyword">for</span> (pos = list_entry((head)-&gt;prev, typeof(*pos), member),    \
        n = list_entry(pos-&gt;member.prev, typeof(*pos), member);    \
         &amp;pos-&gt;member != (head);                     \
         pos = n, n = list_entry(n-&gt;member.prev, typeof(*n), member))

<span class="hljs-comment">/**
 * list_for_each_rcu    -    iterate over an rcu-protected list
 * @pos:    the &amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as list_add_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_rcu(pos, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;next; \
        prefetch(rcu_dereference(pos)-&gt;next), pos != (head); \
            pos = pos-&gt;next)

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> __list_for_each_rcu(pos, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;next; \
        rcu_dereference(pos) != (head); \
            pos = pos-&gt;next)

<span class="hljs-comment">/**
 * list_for_each_safe_rcu
 * @pos:    the &amp;struct list_head to use as a loop cursor.
 * @n:        another &amp;struct list_head to use as temporary storage
 * @head:    the head for your list.
 *
 * Iterate over an rcu-protected list, safe against removal of list entry.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as list_add_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_safe_rcu(pos, n, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;next; \
        n = rcu_dereference(pos)-&gt;next, pos != (head); \
        pos = n)

<span class="hljs-comment">/**
 * list_for_each_entry_rcu    -    iterate over rcu list of given type
 * @pos:    the type * to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the list_struct within the struct.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as list_add_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_entry_rcu(pos, head, member) \</span>
    <span class="hljs-keyword">for</span> (pos = list_entry((head)-&gt;next, typeof(*pos), member); \
        prefetch(rcu_dereference(pos)-&gt;member.next), \
            &amp;pos-&gt;member != (head); \
        pos = list_entry(pos-&gt;member.next, typeof(*pos), member))


<span class="hljs-comment">/**
 * list_for_each_continue_rcu
 * @pos:    the &amp;struct list_head to use as a loop cursor.
 * @head:    the head for your list.
 *
 * Iterate over an rcu-protected list, continuing after current point.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as list_add_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> list_for_each_continue_rcu(pos, head) \</span>
    <span class="hljs-keyword">for</span> ((pos) = (pos)-&gt;next; \
        prefetch(rcu_dereference((pos))-&gt;next), (pos) != (head); \
            (pos) = (pos)-&gt;next)

<span class="hljs-comment">/*
 * Double linked lists with a single pointer list head.
 * Mostly useful for hash tables where the two pointer list head is
 * too wasteful.
 * You lose the ability to access the tail in O(1).
 */</span>

<span class="hljs-keyword">struct</span> hlist_head {
    <span class="hljs-keyword">struct</span> hlist_node *first;
};

<span class="hljs-keyword">struct</span> hlist_node {
    <span class="hljs-keyword">struct</span> hlist_node *next, **pprev;
};

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> HLIST_HEAD_INIT { .first = NULL }</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> HLIST_HEAD(name) struct hlist_head name = {  .first = NULL }</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> INIT_HLIST_HEAD(ptr) ((ptr)-&gt;first = NULL)</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> INIT_HLIST_NODE(<span class="hljs-keyword">struct</span> hlist_node *h)
{
    h-&gt;next = NULL;
    h-&gt;pprev = NULL;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> hlist_unhashed(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> hlist_node *h)
{
    <span class="hljs-keyword">return</span> !h-&gt;pprev;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> hlist_empty(<span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> hlist_head *h)
{
    <span class="hljs-keyword">return</span> !h-&gt;first;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> __hlist_del(<span class="hljs-keyword">struct</span> hlist_node *n)
{
    <span class="hljs-keyword">struct</span> hlist_node *next = n-&gt;next;
    <span class="hljs-keyword">struct</span> hlist_node **pprev = n-&gt;pprev;
    *pprev = next;
    <span class="hljs-keyword">if</span> (next)
        next-&gt;pprev = pprev;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_del(<span class="hljs-keyword">struct</span> hlist_node *n)
{
    __hlist_del(n);
    n-&gt;next = LIST_POISON1;
    n-&gt;pprev = LIST_POISON2;
}

<span class="hljs-comment">/**
 * hlist_del_rcu - deletes entry from hash list without re-initialization
 * @n: the element to delete from the hash list.
 *
 * Note: list_unhashed() on entry does not return true after this,
 * the entry is in an undefined state. It is useful for RCU based
 * lockfree traversal.
 *
 * In particular, it means that we can not poison the forward
 * pointers that may still be used for walking the hash list.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_add_head_rcu()
 * or hlist_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_for_each_entry().
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_del_rcu(<span class="hljs-keyword">struct</span> hlist_node *n)
{
    __hlist_del(n);
    n-&gt;pprev = LIST_POISON2;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_del_init(<span class="hljs-keyword">struct</span> hlist_node *n)
{
    <span class="hljs-keyword">if</span> (!hlist_unhashed(n)) {
        __hlist_del(n);
        INIT_HLIST_NODE(n);
    }
}

<span class="hljs-comment">/**
 * hlist_replace_rcu - replace old entry by new one
 * @old : the element to be replaced
 * @new : the new element to insert
 *
 * The @old entry will be replaced with the @new entry atomically.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_replace_rcu(<span class="hljs-keyword">struct</span> hlist_node *old,
                    <span class="hljs-keyword">struct</span> hlist_node *<span class="hljs-keyword">new</span>)
{
    <span class="hljs-keyword">struct</span> hlist_node *next = old-&gt;next;

    <span class="hljs-keyword">new</span>-&gt;next = next;
    <span class="hljs-keyword">new</span>-&gt;pprev = old-&gt;pprev;
    smp_wmb();
    <span class="hljs-keyword">if</span> (next)
        <span class="hljs-keyword">new</span>-&gt;next-&gt;pprev = &amp;<span class="hljs-keyword">new</span>-&gt;next;
    *<span class="hljs-keyword">new</span>-&gt;pprev = <span class="hljs-keyword">new</span>;
    old-&gt;pprev = LIST_POISON2;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_add_head(<span class="hljs-keyword">struct</span> hlist_node *n, <span class="hljs-keyword">struct</span> hlist_head *h)
{
    <span class="hljs-keyword">struct</span> hlist_node *first = h-&gt;first;
    n-&gt;next = first;
    <span class="hljs-keyword">if</span> (first)
        first-&gt;pprev = &amp;n-&gt;next;
    h-&gt;first = n;
    n-&gt;pprev = &amp;h-&gt;first;
}


<span class="hljs-comment">/**
 * hlist_add_head_rcu
 * @n: the element to add to the hash list.
 * @h: the list to add to.
 *
 * Description:
 * Adds the specified element to the specified hlist,
 * while permitting racing traversals.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_add_head_rcu()
 * or hlist_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_for_each_entry_rcu(), used to prevent memory-consistency
 * problems on Alpha CPUs.  Regardless of the type of CPU, the
 * list-traversal primitive must be guarded by rcu_read_lock().
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_add_head_rcu(<span class="hljs-keyword">struct</span> hlist_node *n,
                    <span class="hljs-keyword">struct</span> hlist_head *h)
{
    <span class="hljs-keyword">struct</span> hlist_node *first = h-&gt;first;
    n-&gt;next = first;
    n-&gt;pprev = &amp;h-&gt;first;
    smp_wmb();
    <span class="hljs-keyword">if</span> (first)
        first-&gt;pprev = &amp;n-&gt;next;
    h-&gt;first = n;
}

<span class="hljs-comment">/* next must be != NULL */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_add_before(<span class="hljs-keyword">struct</span> hlist_node *n,
                    <span class="hljs-keyword">struct</span> hlist_node *next)
{
    n-&gt;pprev = next-&gt;pprev;
    n-&gt;next = next;
    next-&gt;pprev = &amp;n-&gt;next;
    *(n-&gt;pprev) = n;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_add_after(<span class="hljs-keyword">struct</span> hlist_node *n,
                    <span class="hljs-keyword">struct</span> hlist_node *next)
{
    next-&gt;next = n-&gt;next;
    n-&gt;next = next;
    next-&gt;pprev = &amp;n-&gt;next;

    <span class="hljs-keyword">if</span>(next-&gt;next)
        next-&gt;next-&gt;pprev  = &amp;next-&gt;next;
}

<span class="hljs-comment">/**
 * hlist_add_before_rcu
 * @n: the new element to add to the hash list.
 * @next: the existing element to add the new element before.
 *
 * Description:
 * Adds the specified element to the specified hlist
 * before the specified node while permitting racing traversals.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_add_head_rcu()
 * or hlist_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_for_each_entry_rcu(), used to prevent memory-consistency
 * problems on Alpha CPUs.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_add_before_rcu(<span class="hljs-keyword">struct</span> hlist_node *n,
                    <span class="hljs-keyword">struct</span> hlist_node *next)
{
    n-&gt;pprev = next-&gt;pprev;
    n-&gt;next = next;
    smp_wmb();
    next-&gt;pprev = &amp;n-&gt;next;
    *(n-&gt;pprev) = n;
}

<span class="hljs-comment">/**
 * hlist_add_after_rcu
 * @prev: the existing element to add the new element after.
 * @n: the new element to add to the hash list.
 *
 * Description:
 * Adds the specified element to the specified hlist
 * after the specified node while permitting racing traversals.
 *
 * The caller must take whatever precautions are necessary
 * (such as holding appropriate locks) to avoid racing
 * with another list-mutation primitive, such as hlist_add_head_rcu()
 * or hlist_del_rcu(), running on this same list.
 * However, it is perfectly legal to run concurrently with
 * the _rcu list-traversal primitives, such as
 * hlist_for_each_entry_rcu(), used to prevent memory-consistency
 * problems on Alpha CPUs.
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> hlist_add_after_rcu(<span class="hljs-keyword">struct</span> hlist_node *prev,
                       <span class="hljs-keyword">struct</span> hlist_node *n)
{
    n-&gt;next = prev-&gt;next;
    n-&gt;pprev = &amp;prev-&gt;next;
    smp_wmb();
    prev-&gt;next = n;
    <span class="hljs-keyword">if</span> (n-&gt;next)
        n-&gt;next-&gt;pprev = &amp;n-&gt;next;
}

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> hlist_entry(ptr, type, member) container_of(ptr,type,member)</span>

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> hlist_for_each(pos, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;first; pos &amp;&amp; ({ prefetch(pos-&gt;next); <span class="hljs-number">1</span>; }); \
         pos = pos-&gt;next)

<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> hlist_for_each_safe(pos, n, head) \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;first; pos &amp;&amp; ({ n = pos-&gt;next; <span class="hljs-number">1</span>; }); \
         pos = n)

<span class="hljs-comment">/**
 * hlist_for_each_entry    - iterate over list of given type
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;struct hlist_node to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the hlist_node within the struct.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> hlist_for_each_entry(tpos, pos, head, member)             \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;first;                     \
         pos &amp;&amp; ({ prefetch(pos-&gt;next); <span class="hljs-number">1</span>;}) &amp;&amp;             \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); <span class="hljs-number">1</span>;}); \
         pos = pos-&gt;next)

<span class="hljs-comment">/**
 * hlist_for_each_entry_continue - iterate over a hlist continuing after current point
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;struct hlist_node to use as a loop cursor.
 * @member:    the name of the hlist_node within the struct.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> hlist_for_each_entry_continue(tpos, pos, member)         \</span>
    <span class="hljs-keyword">for</span> (pos = (pos)-&gt;next;                         \
         pos &amp;&amp; ({ prefetch(pos-&gt;next); <span class="hljs-number">1</span>;}) &amp;&amp;             \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); <span class="hljs-number">1</span>;}); \
         pos = pos-&gt;next)

<span class="hljs-comment">/**
 * hlist_for_each_entry_from - iterate over a hlist continuing from current point
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;struct hlist_node to use as a loop cursor.
 * @member:    the name of the hlist_node within the struct.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> hlist_for_each_entry_from(tpos, pos, member)             \</span>
    <span class="hljs-keyword">for</span> (; pos &amp;&amp; ({ prefetch(pos-&gt;next); <span class="hljs-number">1</span>;}) &amp;&amp;             \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); <span class="hljs-number">1</span>;}); \
         pos = pos-&gt;next)

<span class="hljs-comment">/**
 * hlist_for_each_entry_safe - iterate over list of given type safe against removal of list entry
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;struct hlist_node to use as a loop cursor.
 * @n:        another &amp;struct hlist_node to use as temporary storage
 * @head:    the head for your list.
 * @member:    the name of the hlist_node within the struct.
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> hlist_for_each_entry_safe(tpos, pos, n, head, member)          \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;first;                     \
         pos &amp;&amp; ({ n = pos-&gt;next; <span class="hljs-number">1</span>; }) &amp;&amp;                  \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); <span class="hljs-number">1</span>;}); \
         pos = n)

<span class="hljs-comment">/**
 * hlist_for_each_entry_rcu - iterate over rcu list of given type
 * @tpos:    the type * to use as a loop cursor.
 * @pos:    the &amp;struct hlist_node to use as a loop cursor.
 * @head:    the head for your list.
 * @member:    the name of the hlist_node within the struct.
 *
 * This list-traversal primitive may safely run concurrently with
 * the _rcu list-mutation primitives such as hlist_add_head_rcu()
 * as long as the traversal is guarded by rcu_read_lock().
 */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> hlist_for_each_entry_rcu(tpos, pos, head, member)         \</span>
    <span class="hljs-keyword">for</span> (pos = (head)-&gt;first;                     \
         rcu_dereference(pos) &amp;&amp; ({ prefetch(pos-&gt;next); <span class="hljs-number">1</span>;}) &amp;&amp;     \
        ({ tpos = hlist_entry(pos, typeof(*tpos), member); <span class="hljs-number">1</span>;}); \
         pos = pos-&gt;next)

<span class="hljs-preprocessor">#<span class="hljs-keyword">else</span></span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">warning</span> "don't include kernel headers in userspace"</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span> /* __KERNEL__ */</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">endif</span></span>
</code></pre>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
