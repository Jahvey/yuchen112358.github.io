---
layout:     post
title:      "Markdown写作技巧"
subtitle:   "增加目录及显示代码行号"
date:       2016-07-24
author:     "yuchen"
header-img: "img/post-bg-odroid.jpg"
tags:
    - Line Number
    - Markdown
---

# 为博文增加目录

## Catalog

1. [Table](#table)
2. [Reference](#reference)
3. [Line & Code & Embedded](#line--code--embedded)
4. [Block & Code](#block--code)
	- [C](#c)
	- [Java](#java)
	- [Javascript](#javascript)
5. [Catalog & Code](#catalog--code)

## Table

|基本类型|大小|包装器类型|
|:---|:---:|---:|
|boolean|-|Boolean|
|char|16-bit|Character|
|byte|8 bits|Byte|
|short|16 bits|Short|
|int|32 bits|Integer|
|long|64 bits|Long|
|float|32 bits|Float|
|double|64 bits|Double|
|void|-|Void|

## Reference

> Java还可以创建用来存放基本数据类型的数组。同样，编译器也能确保这种数组的初始化，因为它会将这种数组所占的内存全部置零。

## Line & Code & Embedded

所有数值类型都有正负号，故不要去寻找无符号的数值类型。
注意：byte的取值为`Unicode 0`到`Unicode 2^16^-1`。

## Block & Code

代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。

#### C

在C和C++中下述代码合法，但是在Java中却不能这样写：

```c

#include <stdio.h>
int main(int argc, char *argv[])
{
   int c;
   printf("Number of command line arguments passed: %d\n", argc);
   for ( c = 0 ; c < argc ; c++)
      printf("%d. Command line argument passed is %s\n", c+1, argv[c]);
   {
	int x = 12;
	{
		int x = 96;//illegal in Java，因为Java设计者认为这样做会导致程序混乱
	}
   }
   return 0;
}
```

```c
//src/libcore/RunningProcs.cpp
void RunningProcs::switchIn(CPU_t id, ProcessId *proc)
{
  GProcessor *core=getProcessor(id);

  workingListAdd(core);

  proc->switchIn(id);
#ifdef TS_STALL  
  core->setStallUntil(globalClock+5);
#endif  
  core->switchIn(proc->getPid()); // Must be the last thing because it can generate a switch
}

void RunningProcs::switchOut(CPU_t id, ProcessId *proc) 
{
  GProcessor *core=getProcessor(id);
  Pid_t pid = proc->getPid();

  proc->switchOut(core->getAndClearnGradInsts(pid),
                  core->getAndClearnWPathInsts(pid));

  core->switchOut(pid);

  workingListRemove(core);
}
```

#### Java

Java中类变量和局部变量可以同名，如下所示：


```java

public class HelloGridWorld {

	public static void main(String[] args) {

		GridWorldDomain gw = new GridWorldDomain(11,11); //11x11 grid world
		gw.setMapToFourRooms(); //four rooms layout
		gw.setProbSucceedTransitionDynamics(0.8);
		exp.initGUI();

	}

}

```

```java
// Constructor initialization with composition.
import static net.mindview.util.Print.*;

class Soap {
  private String s;
  Soap() {
    print("Soap()");
    //2.在类的构造器中初始化
    s = "Constructed";
  }
  public String toString() { return s; }
}    

public class Bath {
  private String // 1.在定义对象的地方初始化：
    s1 = "Happy",
    s2 = "Happy",
    s3, s4;
  private Soap castille;
  private int i;
  private float toy;
  public Bath() {
    print("Inside Bath()");
    //2.在类的构造器中初始化：
    s3 = "Joy";
    toy = 3.14f;
    castille = new Soap();
  }    
  // 4.实例初始化:
  { i = 47; }
  public String toString() {
    if(s4 == null) // 3.惰性初始化(Delayed initialization):
      s4 = "Joy";
    return
      "s1 = " + s1 + "\n" +
      "s2 = " + s2 + "\n" +
      "s3 = " + s3 + "\n" +
      "s4 = " + s4 + "\n" +
      "i = " + i + "\n" +
      "toy = " + toy + "\n" +
      "castille = " + castille;
  }    
  public static void main(String[] args) {
    Bath b = new Bath();
    print(b);
  }
} /* Output:
Inside Bath()
Soap()
s1 = Happy
s2 = Happy
s3 = Joy
s4 = Joy
i = 47
toy = 3.14
castille = Constructed
*///:~
```

#### Javascript

Javascript代码如下：

```js
//AMD Wrapper

define(
    [types/Employee],    //依赖
    function(Employee){  //这个回调会在所有依赖都被加载后才执行

        function Programmer(){
            //do something
        };

        Programmer.prototype = new Employee();
        return Programmer;  //return Constructor
    }
)
```

## Catalog & Code

```markdown
1. [Table](#table)
2. [Reference](#reference)
3. [Line & Code & Embedded](#line--code--embedded)
4. [Block & Code](#block--code)
	- [C](#c)
	- [Java](#java)
5. [Catalog & Code](#catalog--code)
```

**注意1：**增加目录的代码中，每个目录名不能为中文，且两个及两个以上单词的目录名之间需要添加`&`符号分隔。`#`号后的引用必须为目录名的小写格式，且将`&`符号换成`--`符号。  
**注意2：**每个标题要上下各空一行，每个代码块上下也要各空一行，每级标题1~6个`#`后都要先空一个空格再写标题名，这样才不会出现Markdown解析错误。

## 附录

也可以采用另外一种目录显示的代码风格(可采用中文作为目录)，代码如下：

```markdown

<a name="catalog" />

### 目录

* [概述](#overview)
	+ [宗旨](#philosophy)
	+ [兼容 HTML](#html)
* [区块元素](#block)
	+ [段落和换行](#p)
	+ [标题](#headers)
* [感谢](#acknowledgement)
* [参考文献](#ref)

***

<a name="overview" />

### 概述

<a name="philosophy" />

##### 宗旨

<a name="html" />

##### 兼容 HTML

<a name="block" />

### 区块元素

<a name="p" />

##### 段落和换行

<a name="headers" />

##### 标题

<a name="acknowledgement" />

### 感谢

<a name="ref" />

### 参考文献
```

显示效果如下：

<a name="catalog" />

### 目录

* [概述](#overview)
	+ [宗旨](#philosophy)
	+ [兼容 HTML](#html)
* [区块元素](#block)
	+ [段落和换行](#p)
	+ [标题](#headers)
* [感谢](#acknowledgement)
* [参考文献](#ref)

***

<a name="overview" />

### 概述

<a name="philosophy" />

##### 宗旨

<a name="html" />

##### 兼容 HTML

<a name="block" />

### 区块元素

<a name="p" />

##### 段落和换行

<a name="headers" />

##### 标题

<a name="acknowledgement" />

### 感谢

<a name="ref" />

### 参考文献

个人主页： <http://www.wzzju.top>

博主邮箱： <wzzju@mail.ustc.edu.cn>